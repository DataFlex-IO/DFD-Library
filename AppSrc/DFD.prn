Compiling Program: E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\DFD.src
Memory Available: 2147483646
1>Use DFD.pkg
Including file: DFD.pkg    (E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\DFD.pkg)
1>>>// Data Access
1>>>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (E:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>>>
67438>>>// DFD Base Library Classes
67438>>>Use base\cDFD_Object.pkg
Including file: base\cDFD_Object.pkg    (E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\base\cDFD_Object.pkg)
67438>>>>>//TH-Header
67438>>>>>//*****************************************************************************************
67438>>>>>// Copyright (c)  2006-2020  Todd Forsberg
67438>>>>>// All rights reserved.
67438>>>>>//
67438>>>>>// $FileName    : GitHub\DataFlex-IO\DFD-Library\AppSrc\base\cDFD_Object.pkg
67438>>>>>// $ProjectName : DataFlex Developer Library
67438>>>>>// $Authors     : Todd Forsberg
67438>>>>>// $Created     : July 10, 2017
67438>>>>>//
67438>>>>>// Contents: A generic base class for building other classes upon
67438>>>>>//
67438>>>>>//*****************************************************************************************
67438>>>>>//TH-RevisionStart
67438>>>>>//TH-RevisionEnd
67438>>>>>//*****************************************************************************************
67438>>>>>
67438>>>>>//Use mixin\cDFD_ClassNameArray_Mixin.pkg
67438>>>>>//Use mixin\cDFD_RegisterPropertyHandle_Mixin.pkg
67438>>>>>
67438>>>>>Class cDFD_Object Is A cObject
67439>>>>>
67439>>>>>//    Import_Class_Protocol cDFD_ClassNameArray_Mixin
67439>>>>>//    Import_Class_Protocol cDFD_RegisterPropertyHandle_Mixin
67439>>>>>
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>
67443>>>>>//        Send Define_DFD_ClassNameArray_Mixin
67443>>>>>//        Send Define_DFD_RegisterPropertyHandle_Mixin
67443>>>>>
67443>>>>>//        Send AddClassName "cObject"  //add base classname
67443>>>>>//        Send AddClassName "!$"  //add this classname
67443>>>>>
67443>>>>>        // Define new Properties:
67443>>>>>
67443>>>>>        // Create child objects:
67443>>>>>
67443>>>>>        // Set property values:
67443>>>>>
67443>>>>>    End_Procedure
67444>>>>>
67444>>>>>    Procedure End_Construct_Object
67446>>>>>        Forward Send End_Construct_Object
67448>>>>>//        Send End_Define_DFD_ClassNameArray_Mixin
67448>>>>>        // Add your code that needs to be executed at the end of the object construction here:
67448>>>>>
67448>>>>>    End_Procedure
67449>>>>>
67449>>>>>    // Create and augment procedures and functions
67449>>>>>
67449>>>>>End_Class
67450>>>>>
67450>>>>>//==============================//
67450>>>>>// End of File: cDFD_Object.pkg //
67450>>>>>//==============================//
67450>>>Use base\cDFD_Collection.pkg
Including file: base\cDFD_Collection.pkg    (E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\base\cDFD_Collection.pkg)
67450>>>>>// Top of File: cDFD_Collection.pkg
67450>>>>>
67450>>>>>Use cCollection.pkg
Including file: cCollection.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cCollection.pkg)
67450>>>>>>>Use VDFBase.pkg
67450>>>>>>>
67450>>>>>>>Register_Function IsObjectIn Handle ho Returns Integer
67450>>>>>>>
67450>>>>>>>Class cCollection is a Array
67451>>>>>>>    Procedure Construct_Object
67453>>>>>>>        Forward Send Construct_Object
67455>>>>>>>        Property Boolean pbAllowDuplicates False
67456>>>>>>>    End_Procedure
67457>>>>>>>    
67457>>>>>>>    Procedure DoAppendObject Handle ho
67459>>>>>>>        If (pbAllowDuplicates(Self) = False) Begin
67461>>>>>>>            If (IsObjectIn(Self, ho)) ;                Procedure_Return
67464>>>>>>>        End
67464>>>>>>>>
67464>>>>>>>        Set Value (Item_Count(Self)) to ho
67465>>>>>>>    End_Procedure
67466>>>>>>>    
67466>>>>>>>    Procedure DoRemoveObject Handle ho
67468>>>>>>>        Integer iIndex
67468>>>>>>>        Get IndexFromObject ho to iIndex
67469>>>>>>>        If (iIndex <> -1) ;            Send Delete_Item iIndex
67472>>>>>>>    End_Procedure
67473>>>>>>>    
67473>>>>>>>    Procedure DoInsertObject Handle ho Handle hoBefore
67475>>>>>>>        Integer iIndex icObject iObject
67475>>>>>>>        
67475>>>>>>>        If (pbAllowDuplicates(Self) = False) Begin
67477>>>>>>>            If (IsObjectIn(Self, ho)) ;                Procedure_Return
67480>>>>>>>        End
67480>>>>>>>>
67480>>>>>>>        
67480>>>>>>>        Get IndexFromObject hoBefore to iIndex
67481>>>>>>>        If (iIndex <> -1) Begin
67483>>>>>>>            Get CountOfObjects to icObject
67484>>>>>>>            For iObject from 0 to (icObject -iIndex -1)
67490>>>>>>>>
67490>>>>>>>                Set Value (icObject -iObject) to (Value(Self, icObject -iObject -1))
67491>>>>>>>            Loop
67492>>>>>>>>
67492>>>>>>>            Set Value iIndex to ho
67493>>>>>>>        End
67493>>>>>>>>
67493>>>>>>>        
67493>>>>>>>    End_Procedure
67494>>>>>>>    
67494>>>>>>>    Function ObjectFromIndex Integer iIndex Returns Handle
67496>>>>>>>        // Returns the object-handle of the zero-based Button-index
67496>>>>>>>        Integer icObject
67496>>>>>>>        Handle hoObject
67496>>>>>>>        
67496>>>>>>>        Get Item_Count to icObject
67497>>>>>>>        
67497>>>>>>>        If (iIndex < icObject) ;            Get Value iIndex to hoObject
67500>>>>>>>        Else ;            Move 0 to hoObject
67502>>>>>>>        
67502>>>>>>>        Function_Return hoObject
67503>>>>>>>    End_Function
67504>>>>>>>    
67504>>>>>>>    Function IndexFromObject Handle ho Returns Integer
67506>>>>>>>        // Returns the index of the object, ho, in the collection
67506>>>>>>>        Integer iIndex iItem
67506>>>>>>>        
67506>>>>>>>        For iIndex from 0 to (Item_Count(Self) -1)
67512>>>>>>>>
67512>>>>>>>            If (Value(Self, iIndex) = ho) ;                Function_Return iIndex
67515>>>>>>>        Loop
67516>>>>>>>>
67516>>>>>>>        Function_Return -1 // object not found
67517>>>>>>>    End_Function
67518>>>>>>>    
67518>>>>>>>    Function CountOfObjects Returns Integer
67520>>>>>>>        Function_Return (Item_Count(Self))
67521>>>>>>>    End_Function
67522>>>>>>>    
67522>>>>>>>    Function IsObjectIn Handle ho Returns Boolean
67524>>>>>>>        // Is an object in the collection already?
67524>>>>>>>        Integer iIndex
67524>>>>>>>        
67524>>>>>>>        Get IndexFromObject ho to iIndex
67525>>>>>>>        
67525>>>>>>>        Function_Return (iIndex <> -1)
67526>>>>>>>    End_Function
67527>>>>>>>    
67527>>>>>>>End_Class
67528>>>>>>>
67528>>>>>>>
67528>>>>>
67528>>>>>Class cDFD_Collection is a cCollection
67529>>>>>End_Class
67530>>>>>
67530>>>>>// End of File: cDFD_Collection.pkg
67530>>>Use base\cDFD_Broadcaster.pkg
Including file: base\cDFD_Broadcaster.pkg    (E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\base\cDFD_Broadcaster.pkg)
67530>>>>>Use brdcster.pkg
67530>>>>>Use base\cDFD_Set.pkg
Including file: base\cDFD_Set.pkg    (E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\base\cDFD_Set.pkg)
67530>>>>>>>
67530>>>>>>>//***************************************************************************
67530>>>>>>>//*
67530>>>>>>>//* Class:        cVDFD_Set
67530>>>>>>>//* Package Name: cVDFD_Set.pkg
67530>>>>>>>//*
67530>>>>>>>//***************************************************************************
67530>>>>>>>
67530>>>>>>>Use Set.pkg
67530>>>>>>>Use Flexml.pkg
Including file: Flexml.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\Flexml.pkg)
67530>>>>>>>>>Use VdfBase.pkg
67530>>>>>>>>>Use LanguageText.pkg
67530>>>>>>>>>Use GlobalFunctionsProcedures.pkg
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>// Used to designate that a handle is a handle to an Xml Dom object. This
67530>>>>>>>>>// is used/required by server web-services but could be used elsewhere .
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>// Types of Nodes
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>// classes and methods defined in fmac
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>Register_Function transformNode Handle infcXSLNode Returns String
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>// XML function & procedure registration
67530>>>>>>>>>
67530>>>>>>>>>Register_Procedure Set XmlInterface Handle iHandle
67530>>>>>>>>>Register_Function XmlInterface Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>// NODE Properties
67530>>>>>>>>>Register_Function phAttributes Returns Handle
67530>>>>>>>>>Register_Function psBaseName Returns String
67530>>>>>>>>>Register_Function phChildNodes Returns Handle
67530>>>>>>>>>Register_Function phDefinition Returns Handle
67530>>>>>>>>>Register_Function phFirstChild Returns Handle
67530>>>>>>>>>Register_Function phLastChild Returns Handle
67530>>>>>>>>>Register_Function phNextSibling Returns Handle
67530>>>>>>>>>Register_Function psNameSpaceURI Returns String
67530>>>>>>>>>Register_Function psNodeName Returns String
67530>>>>>>>>>Register_Function piNodeType Returns Integer
67530>>>>>>>>>Register_Function psNodeTypeString Returns String
67530>>>>>>>>>Register_Function phOwnerDocument Returns Handle
67530>>>>>>>>>Register_Function phParentNode Returns Handle
67530>>>>>>>>>Register_Function pbParsed Returns Integer
67530>>>>>>>>>Register_Function psPrefix Returns String
67530>>>>>>>>>Register_Function phPreviousSibling Returns Handle
67530>>>>>>>>>Register_Function pbSpecified Returns Integer
67530>>>>>>>>>Register_Function psText Returns String
67530>>>>>>>>>Register_Procedure Set psText String sText
67530>>>>>>>>>Register_Function psXML Returns String
67530>>>>>>>>>
67530>>>>>>>>>// Node Read write properties
67530>>>>>>>>>
67530>>>>>>>>>Register_Procedure Set psDataType String sTypeName
67530>>>>>>>>>Register_Function psDataType Returns String
67530>>>>>>>>>Register_Procedure Set pvNodeTypedValue Integer iType Integer iAddress
67530>>>>>>>>>Register_Function pvNodeTypedValue Integer iType Returns Integer  // address of data
67530>>>>>>>>>Register_Procedure Set psNodeValue String sValue
67530>>>>>>>>>Register_Function psNodeValue Returns String
67530>>>>>>>>>
67530>>>>>>>>>// Node Methods
67530>>>>>>>>>
67530>>>>>>>>>Register_Function AppendChild Handle iChildInfc Returns Handle
67530>>>>>>>>>Register_Function CloneInfcNode Handle bRecurse Returns Handle
67530>>>>>>>>>Register_Function HasChildNodes Returns Integer
67530>>>>>>>>>Register_Function InsertBefore Handle infcNodeToInsert Handle iWhere Returns Handle
67530>>>>>>>>>Register_Function RemoveChild Handle iChildToRemove Returns Handle
67530>>>>>>>>>Register_Function ReplaceChild Handle iNewChild Handle iChildToReplace Returns Handle
67530>>>>>>>>>Register_Function SelectNodes String selectstring Returns Handle
67530>>>>>>>>>Register_Function SelectSingleNode String selectstring Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>// Node Collections
67530>>>>>>>>>// READONLY PROPERTIES
67530>>>>>>>>>
67530>>>>>>>>>Register_Function phItem Integer iItem Returns Handle
67530>>>>>>>>>Register_Function phElementItem Integer iItem Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>Register_Function piLength Returns Integer
67530>>>>>>>>>
67530>>>>>>>>>Register_Function NamedItem String sName Returns Handle
67530>>>>>>>>>Register_Function QualifiedItem String sBaseName String sNameSpace Returns Handle
67530>>>>>>>>>Register_Function RemoveNamedItem String sName Returns Handle
67530>>>>>>>>>Register_Function RemoveQualifiedItem String sBaseName String sNameSpace Returns Handle
67530>>>>>>>>>Register_Function SetNamedItem Handle iInterface Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>// XML DOM Document
67530>>>>>>>>>// Read only properties
67530>>>>>>>>>
67530>>>>>>>>>Register_Function phDocType Returns Handle
67530>>>>>>>>>Register_Function phImplementation Returns Handle
67530>>>>>>>>>Register_Function phParseError Returns Handle
67530>>>>>>>>>Register_Function piReadyState Returns Integer
67530>>>>>>>>>Register_Function psURL Returns String
67530>>>>>>>>>
67530>>>>>>>>>// Read Write Properties
67530>>>>>>>>>
67530>>>>>>>>>Register_Procedure Set pbAsync Integer bValue
67530>>>>>>>>>Register_Function pbAsync Returns Integer
67530>>>>>>>>>Register_Procedure Set phDocumentElement Handle iElement
67530>>>>>>>>>Register_Function phDocumentElement Returns Handle
67530>>>>>>>>>Register_Procedure Set pbPreserveWhiteSpace Integer bValue
67530>>>>>>>>>Register_Function pbPreserveWhiteSpace Returns Integer
67530>>>>>>>>>Register_Procedure Set pbResolveExternals Integer bValue
67530>>>>>>>>>Register_Function pbResolveExternals Returns Integer
67530>>>>>>>>>Register_Procedure Set pbValidateOnParse Integer bValue
67530>>>>>>>>>Register_Function pbValidateOnParse Returns Integer
67530>>>>>>>>>
67530>>>>>>>>>// Events
67530>>>>>>>>>
67530>>>>>>>>>// Methods
67530>>>>>>>>>
67530>>>>>>>>>Register_Function Abort Returns Integer
67530>>>>>>>>>Register_Function ElementsByTagName String sTagName Returns Handle
67530>>>>>>>>>Register_Function LoadDocument String sURLName Returns Integer
67530>>>>>>>>>Register_Function LoadXML String sXMLText Returns Integer
67530>>>>>>>>>Register_Function NodeFromID String sNodeName Returns Handle
67530>>>>>>>>>Register_Function SaveDocument String sURLName Returns Integer
67530>>>>>>>>>
67530>>>>>>>>>// Parse Error
67530>>>>>>>>>// Read Only Properties
67530>>>>>>>>>
67530>>>>>>>>>Register_Function piErrorCode Returns Integer
67530>>>>>>>>>Register_Function piFilePos Returns Integer
67530>>>>>>>>>Register_Function piLine Returns Integer
67530>>>>>>>>>Register_Function piLinePos Returns Integer
67530>>>>>>>>>Register_Function psReason Returns String
67530>>>>>>>>>Register_Function psSrcText Returns String
67530>>>>>>>>>Register_Function psURL Returns String
67530>>>>>>>>>
67530>>>>>>>>>// DOM Implementation
67530>>>>>>>>>// Method
67530>>>>>>>>>
67530>>>>>>>>>Register_Function HasFeature String sSystem String sFeature Returns Integer
67530>>>>>>>>>
67530>>>>>>>>>// Methods
67530>>>>>>>>>
67530>>>>>>>>>Register_Function substringData Integer iOffset Integer iCount Returns String
67530>>>>>>>>>Register_Function appendData String sData Returns Handle
67530>>>>>>>>>Register_Function insertData Integer iOffset String sData Returns Handle
67530>>>>>>>>>Register_Function deleteData Integer iOffset Integer iCount Returns Handle
67530>>>>>>>>>Register_Function replaceData Integer iOffset Integer iCount String sData Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>// Attributes
67530>>>>>>>>>
67530>>>>>>>>>Register_Function psName Returns String
67530>>>>>>>>>
67530>>>>>>>>>// Elements
67530>>>>>>>>>// Read Only properties
67530>>>>>>>>>
67530>>>>>>>>>Register_Function psTagName Returns String
67530>>>>>>>>>
67530>>>>>>>>>// Methods
67530>>>>>>>>>
67530>>>>>>>>>Register_Procedure Set attributeValue String sName String sValue
67530>>>>>>>>>Register_Function attributeValue String sName Returns String
67530>>>>>>>>>Register_Function removeAttribute String sName Returns Handle
67530>>>>>>>>>Register_Function attributeNode String sName Returns Handle
67530>>>>>>>>>Register_Procedure Set attributeNode Handle iNode Returns Handle
67530>>>>>>>>>Register_Function removeAttributeNode Handle iNode Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>// DOM Text
67530>>>>>>>>>// Methods
67530>>>>>>>>>
67530>>>>>>>>>Register_Function splitText Integer iOffset Returns Integer
67530>>>>>>>>>
67530>>>>>>>>>// DOM Processing Instruction
67530>>>>>>>>>// Read Only Properties
67530>>>>>>>>>Register_Function psTarget Returns String
67530>>>>>>>>>
67530>>>>>>>>>// DOM Document Type
67530>>>>>>>>>
67530>>>>>>>>>Register_Function phEntities Returns Handle
67530>>>>>>>>>Register_Function phNotations Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>// DOM Notations
67530>>>>>>>>>
67530>>>>>>>>>Register_Function psPublicID Returns String
67530>>>>>>>>>Register_Function psSystemID Returns String
67530>>>>>>>>>Register_Function psNotationName Returns String
67530>>>>>>>>>
67530>>>>>>>>>// create nodes
67530>>>>>>>>>
67530>>>>>>>>>Register_Function createAttribute String sName Returns Handle
67530>>>>>>>>>Register_Function createCDataSection String sValue Returns Handle
67530>>>>>>>>>Register_Function createComment String sValue Returns Handle
67530>>>>>>>>>Register_Function createDocumentFragment Returns Handle
67530>>>>>>>>>Register_Function createElement String sTagName Returns Handle
67530>>>>>>>>>Register_Function createEntityReference String sEntityName Returns Handle
67530>>>>>>>>>Register_Function createNode Integer iNodeType String sName String sNameSpace Returns Handle
67530>>>>>>>>>Register_Function createProcessingInstruction String sTarget String sData Returns Handle
67530>>>>>>>>>Register_Function createTextNode String sData Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>Register_Function ChangeNodeType Integer iTypeOfNode Integer bSetInterface Returns Handle
67530>>>>>>>>>
67530>>>>>>>>>
67530>>>>>>>>>//          Part 1:  Base Document Logic Specialized For Templates
67530>>>>>>>>>
67530>>>>>>>>>//
67530>>>>>>>>>//  XML Collections
67530>>>>>>>>>//
67530>>>>>>>>>//  Collection mixin has common functions to both node lists and named node maps
67530>>>>>>>>>//
67530>>>>>>>>>
67530>>>>>>>>>// This provides functions required of all XMLDOM objects.
67530>>>>>>>>>//
67530>>>>>>>>>Class cXMLDOMMixin is a Mixin
67531>>>>>>>>>    
67531>>>>>>>>>    // Create an XML object of passed class Id and bind passed interface. returns
67531>>>>>>>>>    // the object handle. All dynamic XML object can be created using this syntax
67531>>>>>>>>>    
67531>>>>>>>>>    Function CreateXMLObject Integer iClassId Handle hinfXMLInterface Returns Handle
67533>>>>>>>>>        Handle hoId hoDocument
67533>>>>>>>>>        // We will always create objects at the DOMDocument level.
67533>>>>>>>>>        Get DocumentObject to hoDocument
67534>>>>>>>>>        If (hoDocument=0) Begin  // this should never happen.
67536>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR C_$XmlFailedNoDocObject
67537>>>>>>>>>>
67537>>>>>>>>>            Function_Return 0
67538>>>>>>>>>        End
67538>>>>>>>>>>
67538>>>>>>>>>        If hinfXMLInterface Begin
67540>>>>>>>>>            Get Create of hoDocument iClassId to hoID
67541>>>>>>>>>            Set XMLInterface of hoID to hinfXMLInterface
67542>>>>>>>>>        End
67542>>>>>>>>>>
67542>>>>>>>>>        Function_Return hoID
67543>>>>>>>>>    End_Function
67544>>>>>>>>>    
67544>>>>>>>>>    // create an XML Node object based on the interface type.
67544>>>>>>>>>    // this will convert the interface to the proper type and will create
67544>>>>>>>>>    // an appropriate DF object.
67544>>>>>>>>>    // This requires that a DocumentObject exists
67544>>>>>>>>>    
67544>>>>>>>>>    Function CreateXMLNode Handle hinfc Returns Handle
67546>>>>>>>>>        Integer iType iClassId
67546>>>>>>>>>        Handle  hoDocument hoNode
67546>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
67546>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
67547>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
67548>>>>>>>>>        If (hinfc=0) Begin
67550>>>>>>>>>            // this should not happen and we would need to know about this.
67550>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
67551>>>>>>>>>>
67551>>>>>>>>>            Function_Return 0
67552>>>>>>>>>        End
67552>>>>>>>>>>
67552>>>>>>>>>        Get DocumentObject to hoDocument
67553>>>>>>>>>        // you can augment your class IDs in a single place.
67553>>>>>>>>>        Get NodeClassId of hoDocument iType to iClassId
67554>>>>>>>>>        Get CreateXMLObject of hoDocument iClassId hinfc to hoNode
67555>>>>>>>>>        
67555>>>>>>>>>        Function_Return hoNode
67556>>>>>>>>>    End_Function
67557>>>>>>>>>    
67557>>>>>>>>>    
67557>>>>>>>>>    // Change object's class. This let's you change the class id of an object
67557>>>>>>>>>    // on an object by object basis. This would let you create nodes (e.g. elements)
67557>>>>>>>>>    // that have a custom interface for each node type. Normally, this would be sent
67557>>>>>>>>>    // after a node has been created using one of the default classes
67557>>>>>>>>>    Function ChangeNodeClass Handle hoNode Integer iClassID Returns Handle
67559>>>>>>>>>        Integer iType
67559>>>>>>>>>        Handle  hinfcNew
67559>>>>>>>>>        Get piNodeType of hoNode to iType
67560>>>>>>>>>        Get ChangeNodeType of hoNode iType False to hInfcNew
67561>>>>>>>>>        Send Destroy to hoNode // destroy object and old infc handle.
67562>>>>>>>>>        Get CreateXMLObject iClassId hinfcNew to hoNode
67563>>>>>>>>>        Function_Return hoNode
67564>>>>>>>>>    End_Function
67565>>>>>>>>>    
67565>>>>>>>>>End_Class
67566>>>>>>>>>
67566>>>>>>>>>
67566>>>>>>>>>Class cXMLDOMCollectionMixin is a Mixin
67567>>>>>>>>>    
67567>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
67568>>>>>>>>>    
67568>>>>>>>>>    //  Returns number of items in the collection
67568>>>>>>>>>    //
67568>>>>>>>>>    Function NodeListLength Returns Integer
67570>>>>>>>>>        Integer iLength
67570>>>>>>>>>        Get piLength to iLength
67571>>>>>>>>>        Function_Return iLength
67572>>>>>>>>>    End_Function
67573>>>>>>>>>    
67573>>>>>>>>>    // Returns an XML node object for pass item
67573>>>>>>>>>    //
67573>>>>>>>>>    Function CollectionNode Integer I Returns Handle
67575>>>>>>>>>        Handle hoNewNode
67575>>>>>>>>>        Handle infcItem
67575>>>>>>>>>        Get phItem i to infcItem
67576>>>>>>>>>        If (infcItem) ;            Get CreateXMLNode infcItem to hoNewNode
67579>>>>>>>>>        Function_Return hoNewNode
67580>>>>>>>>>    End_Function
67581>>>>>>>>>    
67581>>>>>>>>>    
67581>>>>>>>>>End_Class
67582>>>>>>>>>
67582>>>>>>>>>// Simple declarations of collections.
67582>>>>>>>>>
67582>>>>>>>>>Class cXMLDOMNodeList is a BaseXmlDomNodeList
67583>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
67584>>>>>>>>>End_Class
67585>>>>>>>>>
67585>>>>>>>>>Class cXMLDOMNamedNodeMap is a BaseXmlDomNamedNodeMap
67586>>>>>>>>>    
67586>>>>>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
67587>>>>>>>>>    
67587>>>>>>>>>    // returns a node attribute that matches passed name, zero if none
67587>>>>>>>>>    Function NamedNode String sName Returns Handle
67589>>>>>>>>>        Handle hoNewNode
67589>>>>>>>>>        Handle infcItem
67589>>>>>>>>>        Get NamedItem sName to infcItem
67590>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
67593>>>>>>>>>        Function_Return hoNewNode
67594>>>>>>>>>    End_Function
67595>>>>>>>>>    
67595>>>>>>>>>    // Adds or changes a node attribute
67595>>>>>>>>>    // This should return the passed object Id which is now bound to the attribute. If an error, returns 0
67595>>>>>>>>>    Function SetNamedNode Handle hoNode Returns Handle
67597>>>>>>>>>        Handle hinfcNode hinfcItem
67597>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode // node of passed attribute
67598>>>>>>>>>        Get SetNamedItem hinfcNode to hinfcItem
67599>>>>>>>>>        If hinfcItem ;            Set XMLInterface of hoNode to hinfcItem
67602>>>>>>>>>        Else ;            Move 0 to hoNode // zero indicates error
67604>>>>>>>>>        Function_Return hoNode
67605>>>>>>>>>    End_Function
67606>>>>>>>>>    
67606>>>>>>>>>    // removes named attribute, Returns handle of removed node or zero if not found.
67606>>>>>>>>>    // Note that returned object must be disposed of or moved somewhere else.
67606>>>>>>>>>    Function RemoveNamedNode String sName Returns Handle
67608>>>>>>>>>        Handle hoNewNode
67608>>>>>>>>>        Handle infcItem
67608>>>>>>>>>        Get RemoveNamedItem sName to infcItem
67609>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
67612>>>>>>>>>        Function_Return hoNewNode
67613>>>>>>>>>    End_Function
67614>>>>>>>>>    
67614>>>>>>>>>    Function QualifiedNode String sNameSpace String sBaseName Returns Handle
67616>>>>>>>>>        Handle hoNewNode
67616>>>>>>>>>        Handle infcItem
67616>>>>>>>>>        Get QualifiedItem  sBaseName sNameSpace  to infcItem
67617>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
67620>>>>>>>>>        Function_Return hoNewNode
67621>>>>>>>>>    End_Function
67622>>>>>>>>>    
67622>>>>>>>>>    Function RemoveQualifiedNode String sNameSpace String sBaseName Returns Handle
67624>>>>>>>>>        Handle hoNewNode
67624>>>>>>>>>        Handle infcItem
67624>>>>>>>>>        Get RemoveQualifiedItem sBaseName sNameSpace to infcItem
67625>>>>>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
67628>>>>>>>>>        Function_Return hoNewNode
67629>>>>>>>>>    End_Function
67630>>>>>>>>>    
67630>>>>>>>>>End_Class
67631>>>>>>>>>
67631>>>>>>>>>
67631>>>>>>>>>
67631>>>>>>>>>// Mixin for nodes.
67631>>>>>>>>>//
67631>>>>>>>>>//  First the declaration of functions that have no object references.
67631>>>>>>>>>//
67631>>>>>>>>>
67631>>>>>>>>>
67631>>>>>>>>>Class cXMLDOMNodeMixin is a Mixin
67632>>>>>>>>>    
67632>>>>>>>>>    Import_Class_Protocol cXMLDOMMixin
67633>>>>>>>>>    
67633>>>>>>>>>    //  Append Node to the end of list. Returns passed Object handle if Ok, 0 if error
67633>>>>>>>>>    
67633>>>>>>>>>    Function AppendNode Handle hoNode Returns Handle
67635>>>>>>>>>        Handle hinfcNode
67635>>>>>>>>>        Handle infcReturned
67635>>>>>>>>>        // Get COM Interface to call Append child.
67635>>>>>>>>>        Get XMLInterface of hoNode to hinfcNode
67636>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
67639>>>>>>>>>        Get AppendChild hinfcNode to infcReturned
67640>>>>>>>>>        // Interface returned is stored in DataFlex object.
67640>>>>>>>>>        If (infcReturned=0) ;            Function_Return 0
67643>>>>>>>>>        Set XMLInterface of hoNode to infcReturned
67644>>>>>>>>>        Function_Return hoNode
67645>>>>>>>>>    End_Function
67646>>>>>>>>>    
67646>>>>>>>>>    //  Insert NewNode before Node. Returns passed newnode Object handle if Ok, 0 if error
67646>>>>>>>>>    
67646>>>>>>>>>    Function InsertBeforeNode Handle hoNewNode Handle hoNode Returns Handle
67648>>>>>>>>>        Handle hinfcNewNode hinfcNode hoRefNode infcReturned
67648>>>>>>>>>        Integer iType
67648>>>>>>>>>        // DOM says if no refnode argument passed or it is 0, append to end
67648>>>>>>>>>        If (Num_Arguments=1) ;            Move 0 to hoRefNode
67651>>>>>>>>>        Else ;            Move hoNode to hoRefNode
67653>>>>>>>>>        Get XMLInterface of hoNewNode to hinfcNewNode
67654>>>>>>>>>        If (hinfcNewNode=0) ;            Function_Return 0
67657>>>>>>>>>        If hoRefNode Begin
67659>>>>>>>>>            Get XMLInterface of hoRefNode to hinfcNode
67660>>>>>>>>>            If (hinfcNode=0) ;                Function_Return 0
67663>>>>>>>>>        End
67663>>>>>>>>>>
67663>>>>>>>>>        Get InsertBefore hinfcNewNode hinfcNode to infcReturned
67664>>>>>>>>>        If (infcReturned=0) ;            Function_Return 0
67667>>>>>>>>>        // Interface returned is stored in DataFlex object.
67667>>>>>>>>>        Set XMLInterface of hoNewNode to infcReturned
67668>>>>>>>>>        Function_Return hoNewNode
67669>>>>>>>>>    End_Function
67670>>>>>>>>>    
67670>>>>>>>>>    //  Remove Node. Returns object Id of removed node, zero if error
67670>>>>>>>>>    //  Important: The node is not destroyed! This lets you move it elsewhere if you want
67670>>>>>>>>>    
67670>>>>>>>>>    Function RemoveNode Handle hoNode Returns Handle
67672>>>>>>>>>        Handle hInfcNode
67672>>>>>>>>>        Get XMLInterface of hoNode to hInfcNode
67673>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
67676>>>>>>>>>        Get RemoveChild hInfcNode to hinfcNode
67677>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
67680>>>>>>>>>        Set XMLInterface of hoNode to hinfcNode
67681>>>>>>>>>        Function_Return hoNode
67682>>>>>>>>>    End_Function
67683>>>>>>>>>    
67683>>>>>>>>>    //  Replace Node. Returns object Id of replaced node, zero if error
67683>>>>>>>>>    //  Important: The replaced node is not destroyed! This lets you move it elsewhere if you want
67683>>>>>>>>>    
67683>>>>>>>>>    Function ReplaceNode Handle hoNewNode Handle hoNodeToReplace Returns Handle
67685>>>>>>>>>        Handle hInfcNewNode hinfcNodetoReplace hinfcNode
67685>>>>>>>>>        Get XMLInterface of hoNewNode       to hInfcNewNode
67686>>>>>>>>>        Get XMLInterface of hoNodetoReplace to hInfcNodetoreplace
67687>>>>>>>>>        If (hinfcNewNode=0 or hInfcNodeToReplace=0) ;            Function_Return 0
67690>>>>>>>>>        Get ReplaceChild hInfcNewNode hinfcNodeToReplace to hinfcNode
67691>>>>>>>>>        If (hinfcNode=0) ;            Function_Return 0
67694>>>>>>>>>        Set XMLInterface of hoNodetoReplace to hinfcNode
67695>>>>>>>>>        Function_Return hoNodetoReplace
67696>>>>>>>>>    End_Function
67697>>>>>>>>>    
67697>>>>>>>>>    // Remove the named node. Returns handle to removed node. You must destroy
67697>>>>>>>>>    // or move this removed object as needed
67697>>>>>>>>>    
67697>>>>>>>>>    Function RemoveNamedNode String sQueryString Returns Handle
67699>>>>>>>>>        Handle hoNode
67699>>>>>>>>>        Handle hInfcTemplate hinfcNode
67699>>>>>>>>>        Integer iRet
67699>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcTemplate
67700>>>>>>>>>        If (hinfcTemplate) Begin
67702>>>>>>>>>            // Remove child returns an interface to the disassociated node.
67702>>>>>>>>>            // It should be disposed by setting it to an object and then calling destroy
67702>>>>>>>>>            Get RemoveChild hInfcTemplate to hInfcNode
67703>>>>>>>>>            // Even if hInfcTemplate and hInfcNode are the same their reference count will be incremented.
67703>>>>>>>>>            // Therefore we must destroy one the interfaces which will decrement the reference count thus
67703>>>>>>>>>            // avoding a memory leak
67703>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, DESTROY_XML_INTERFACE, hInfcTemplate, 0, 0, 0, 0)) to iRet
67704>>>>>>>>>            If hInfcNode ;                Get CreateXMLNode hinfcNode to hoNode
67707>>>>>>>>>        End
67707>>>>>>>>>>
67707>>>>>>>>>        Function_Return hoNode
67708>>>>>>>>>    End_Function
67709>>>>>>>>>    
67709>>>>>>>>>    // This function creates a clone of the passed Node. if bRecurse all child nodes are also
67709>>>>>>>>>    // cloned. The object Id of the new clone object is returned.
67709>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
67709>>>>>>>>>    // the node to the XML Document.
67709>>>>>>>>>    
67709>>>>>>>>>    Function CloneNode Integer bRecurse Returns Handle
67711>>>>>>>>>        Handle hoNewNode
67711>>>>>>>>>        Handle hinfcNewNode
67711>>>>>>>>>        Get CloneInfcNode (If(bRecurse,-1,0)) to hinfcNewNode
67712>>>>>>>>>        If hinfcNewNode ;            Get CreateXMLNode hinfcNewNode to hoNewNode
67715>>>>>>>>>        Function_Return hoNewNode
67716>>>>>>>>>    End_Function
67717>>>>>>>>>    
67717>>>>>>>>>    //  Create a collection of all nodes. returns handle of a cXMLDomNodeList
67717>>>>>>>>>    
67717>>>>>>>>>    Function ChildNodes Returns Handle
67719>>>>>>>>>        Handle infcNodeList
67719>>>>>>>>>        Handle hoNodeList
67719>>>>>>>>>        Get phChildNodes to infcNodeList
67720>>>>>>>>>        If (infcNodeList) ;            Get CreateXMLObject U_cXMLDOMNodeList infcNodeList to hoNodeList
67723>>>>>>>>>        Function_Return hoNodeList
67724>>>>>>>>>    End_Function
67725>>>>>>>>>    
67725>>>>>>>>>    //  Create a collection of all attributes. returns handle of a cXMLDomNodeMapList
67725>>>>>>>>>    
67725>>>>>>>>>    Function AttributeNodes Returns Handle
67727>>>>>>>>>        Handle hoCollectionId   // Object to hold collection
67727>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
67727>>>>>>>>>        Get phAttributes to hinfcAttributes
67728>>>>>>>>>        If (hinfcAttributes) ;            Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcAttributes to hoCollectionId
67731>>>>>>>>>        Function_Return hoCollectionId
67732>>>>>>>>>    End_Function
67733>>>>>>>>>    
67733>>>>>>>>>    //  Create a collection of all attributes for the temporary attribute node object.
67733>>>>>>>>>    //  Using this saves a small amount of time creating and destroying this object but
67733>>>>>>>>>    //  it must be used with care. This binding is temporary!
67733>>>>>>>>>    Function TempAttributeNodes Returns Handle
67735>>>>>>>>>        Handle hoCollectionId hoDocument
67735>>>>>>>>>        Handle hinfcAttributes  // XML Interface for collection
67735>>>>>>>>>        Get phAttributes to hinfcAttributes
67736>>>>>>>>>        If (hinfcAttributes) Begin
67738>>>>>>>>>            Get DocumentObject to hoDocument
67739>>>>>>>>>            Get phoTempDomNodeMap of hoDocument to hoCollectionId
67740>>>>>>>>>            Set XMLInterface of hoCollectionId to hinfcAttributes
67741>>>>>>>>>        End
67741>>>>>>>>>>
67741>>>>>>>>>        Function_Return hoCollectionId
67742>>>>>>>>>    End_Function
67743>>>>>>>>>    
67743>>>>>>>>>    
67743>>>>>>>>>    // Returns a collection of just elements
67743>>>>>>>>>    
67743>>>>>>>>>    Function ElementNodes String sQueryString Returns Handle
67745>>>>>>>>>        Handle hoNodeList
67745>>>>>>>>>        Handle hinfcNodeList
67745>>>>>>>>>        Get ElementsByTagName sQueryString to hinfcNodeList
67746>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
67749>>>>>>>>>        Function_Return hoNodeList
67750>>>>>>>>>    End_Function
67751>>>>>>>>>    
67751>>>>>>>>>    
67751>>>>>>>>>    
67751>>>>>>>>>    // Return object handle for query.
67751>>>>>>>>>    
67751>>>>>>>>>    Function FindNode String sQueryString Returns Handle
67753>>>>>>>>>        Handle hoNode
67753>>>>>>>>>        Handle hinfcNode
67753>>>>>>>>>        Get SelectSingleNode sQueryString to hinfcNode
67754>>>>>>>>>        If (hinfcNode <> 0) ;            Get CreateXMLNode hInfcNode to hoNode
67757>>>>>>>>>        Function_Return hoNode
67758>>>>>>>>>    End_Function
67759>>>>>>>>>    
67759>>>>>>>>>    // Return object handle for a collection node.
67759>>>>>>>>>    
67759>>>>>>>>>    
67759>>>>>>>>>    Function FindNodeList String sQueryString Returns Handle
67761>>>>>>>>>        Handle hoNodeList
67761>>>>>>>>>        Handle hinfcNodeList
67761>>>>>>>>>        Get SelectNodes sQueryString to hinfcNodeList
67762>>>>>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
67765>>>>>>>>>        Function_Return hoNodeList
67766>>>>>>>>>    End_Function
67767>>>>>>>>>    
67767>>>>>>>>>    // The CreatexxxxxNode messages creates an node object for the type specified. Both
67767>>>>>>>>>    // the interface and the object or of the correct type (i.e. element, comment)
67767>>>>>>>>>    // These all return an object handle which can be used to place the object via
67767>>>>>>>>>    // appendNode or InsertBeforeNode
67767>>>>>>>>>    
67767>>>>>>>>>    // This function creates a child element, returning a dataflex object.
67767>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
67767>>>>>>>>>    // the element to the XML Document.
67767>>>>>>>>>    
67767>>>>>>>>>    Function CreateElementNode String sTagName String sValue Returns Handle
67769>>>>>>>>>        Handle hoNewElement
67769>>>>>>>>>        Handle hoDocumentObject
67769>>>>>>>>>        Handle infcNewElement
67769>>>>>>>>>        Integer iClassId
67769>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
67769>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
67769>>>>>>>>>        Get DocumentObject to hoDocumentObject
67770>>>>>>>>>        Get createElement of hoDocumentObject sTagName to infcNewElement
67771>>>>>>>>>        If infcNewElement Begin // if there was an error, no infc handle would be returned
67773>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ELEMENT to iClassId
67774>>>>>>>>>            Get CreateXMLObject iClassId infcNewElement to hoNewElement
67775>>>>>>>>>            If hoNewElement ; // very unlikely this will be zero                Set psText of hoNewElement to sValue
67778>>>>>>>>>        End
67778>>>>>>>>>>
67778>>>>>>>>>        Function_Return hoNewElement
67779>>>>>>>>>    End_Function
67780>>>>>>>>>    
67780>>>>>>>>>    // This function creates an attribute in a document. Attributes are _NOT_ children of an element.
67780>>>>>>>>>    // A DataFlex object is returned. An attribute can be added to an xml document using
67780>>>>>>>>>    // get AddAttributeNode.
67780>>>>>>>>>    
67780>>>>>>>>>    Function CreateAttributeNode String sName String sValue Returns Handle
67782>>>>>>>>>        Handle hoNewAttribute
67782>>>>>>>>>        Handle hoDocumentObject
67782>>>>>>>>>        Handle infcNewAttribute
67782>>>>>>>>>        Integer iClassId
67782>>>>>>>>>        Get DocumentObject to hoDocumentObject
67783>>>>>>>>>        // Create an Attribute in the document and assign its interface to the new DF object.
67783>>>>>>>>>        Get createAttribute of hoDocumentObject sName to infcNewAttribute
67784>>>>>>>>>        If infcNewAttribute Begin // if there was an error, no infc handle would be returned
67786>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_ATTRIBUTE to iClassId
67787>>>>>>>>>            Get CreateXMLObject iClassId infcNewAttribute to hoNewAttribute
67788>>>>>>>>>            // Set the value of the attribute.
67788>>>>>>>>>            If hoNewAttribute ; // very unlikely this will be 0                Set psText of hoNewAttribute to sValue
67791>>>>>>>>>        End
67791>>>>>>>>>>
67791>>>>>>>>>        Function_Return hoNewAttribute
67792>>>>>>>>>    End_Function
67793>>>>>>>>>    
67793>>>>>>>>>    // This function creates a child comment, returning a dataflex object.
67793>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
67793>>>>>>>>>    // the comment to the XML Document.
67793>>>>>>>>>    
67793>>>>>>>>>    Function CreateChildComment String sValue Returns Handle
67795>>>>>>>>>        Handle hoNewComment
67795>>>>>>>>>        Handle hoDocumentObject
67795>>>>>>>>>        Handle infcNewComment
67795>>>>>>>>>        Integer iClassID
67795>>>>>>>>>        Get DocumentObject to hoDocumentObject
67796>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
67796>>>>>>>>>        Get createComment of hoDocumentObject sValue to infcNewComment
67797>>>>>>>>>        If infcNewComment Begin // if there was an error, no infc handle would be returned
67799>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_COMMENT to iClassId
67800>>>>>>>>>            Get CreateXMLObject iClassId infcNewComment to hoNewComment
67801>>>>>>>>>            If hoNewComment ; // very unlikely this will be 0                Set psText of hoNewComment to sValue
67804>>>>>>>>>        End
67804>>>>>>>>>>
67804>>>>>>>>>        Function_Return hoNewComment
67805>>>>>>>>>    End_Function
67806>>>>>>>>>    
67806>>>>>>>>>    // This function creates a child processing instruction, returning a dataflex object.
67806>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
67806>>>>>>>>>    // the processing instruction to the XML Document.
67806>>>>>>>>>    
67806>>>>>>>>>    Function CreateChildProcessingInstruction String sTarget String sValue Returns Handle
67808>>>>>>>>>        Handle hoNewProcessingInstruction
67808>>>>>>>>>        Handle hoDocumentObject
67808>>>>>>>>>        Handle infcNewProcessingInstruction
67808>>>>>>>>>        Integer iClassID
67808>>>>>>>>>        Get DocumentObject to hoDocumentObject
67809>>>>>>>>>        // Create an ProcessingInstruction in the document and assign its interface to the new DF object.
67809>>>>>>>>>        Get createProcessingInstruction of hoDocumentObject sTarget sValue to infcNewProcessingInstruction
67810>>>>>>>>>        If infcNewProcessingInstruction  Begin // if there was an error, no infc handle would be returned
67812>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_PROCESSING_INSTRUCTION to iClassId
67813>>>>>>>>>            Get CreateXMLObject iClassID infcNewProcessingInstruction to hoNewProcessingInstruction
67814>>>>>>>>>        End
67814>>>>>>>>>>
67814>>>>>>>>>        Function_Return hoNewProcessingInstruction
67815>>>>>>>>>    End_Function
67816>>>>>>>>>    
67816>>>>>>>>>    // This function creates a child text node, returning a dataflex object.
67816>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
67816>>>>>>>>>    // the text node to the XML Document.
67816>>>>>>>>>    
67816>>>>>>>>>    Function CreateChildTextNode String sValue Returns Handle
67818>>>>>>>>>        Handle hoNewTextNode
67818>>>>>>>>>        Handle hoDocumentObject
67818>>>>>>>>>        Handle infcNewTextNode
67818>>>>>>>>>        Integer iClassID
67818>>>>>>>>>        Get DocumentObject to hoDocumentObject
67819>>>>>>>>>        // Create an TextNode in the document and assign its interface to the new DF object.
67819>>>>>>>>>        Get createTextNode of hoDocumentObject sValue to infcNewTextNode
67820>>>>>>>>>        If infcNewTextNode Begin // if there was an error, no infc handle would be returned
67822>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_TEXT to iClassId
67823>>>>>>>>>            Get CreateXMLObject iClassId infcNewTextNode to hoNewTextNode
67824>>>>>>>>>        End
67824>>>>>>>>>>
67824>>>>>>>>>        Function_Return hoNewTextNode
67825>>>>>>>>>    End_Function
67826>>>>>>>>>    
67826>>>>>>>>>    // This function creates a cdata text node, returning a dataflex object.
67826>>>>>>>>>    // The interface of the object returned can be used in AppendChild to add
67826>>>>>>>>>    // the cdata node to the XML Document.
67826>>>>>>>>>    
67826>>>>>>>>>    Function CreateCDATASectionNode String sValue Returns Handle
67828>>>>>>>>>        Handle hoNewNode
67828>>>>>>>>>        Handle hoDocumentObject
67828>>>>>>>>>        Handle infcNewNode
67828>>>>>>>>>        Integer iClassId
67828>>>>>>>>>        // The DataFlex objects are created inside the nodes (elements).
67828>>>>>>>>>        // Create an element in the document and assign its interface to the new DF object.
67828>>>>>>>>>        Get DocumentObject to hoDocumentObject
67829>>>>>>>>>        Get createCDATASection of hoDocumentObject sValue to infcNewNode
67830>>>>>>>>>        If infcNewNode Begin
67832>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_CDATA_SECTION to iClassId
67833>>>>>>>>>            Get CreateXMLObject iClassId infcNewNode to hoNewNode
67834>>>>>>>>>        End
67834>>>>>>>>>>
67834>>>>>>>>>        Function_Return hoNewNode
67835>>>>>>>>>    End_Function
67836>>>>>>>>>    
67836>>>>>>>>>    // Create a document fragment.  Document fragments can be used to house nodes temporarily. When
67836>>>>>>>>>    // You append or insert a document fragment (appendNode InsertBeforeNode) child nodes are appended
67836>>>>>>>>>    // to the destination object and not the fragment node itself. This is useful!
67836>>>>>>>>>    
67836>>>>>>>>>    Function CreateDocumentFragmentNode Returns Handle
67838>>>>>>>>>        Handle hoNew
67838>>>>>>>>>        Handle hoDocumentObject
67838>>>>>>>>>        Handle infcNew
67838>>>>>>>>>        Integer iClassID
67838>>>>>>>>>        Get DocumentObject to hoDocumentObject
67839>>>>>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
67839>>>>>>>>>        Get createDocumentFragment of hoDocumentObject to infcNew
67840>>>>>>>>>        If infcNew Begin // if there was an error, no infc handle would be returned
67842>>>>>>>>>            Get NodeClassId of hoDocumentObject NODE_DOCUMENT_FRAGMENT to iClassId
67843>>>>>>>>>            Get CreateXMLObject iClassId infcNew to hoNew
67844>>>>>>>>>        End
67844>>>>>>>>>>
67844>>>>>>>>>        Function_Return hoNew
67845>>>>>>>>>    End_Function
67846>>>>>>>>>    
67846>>>>>>>>>    //  Create a Node of any passed Type (e.g. Node_element). Normally you don't need this as there are
67846>>>>>>>>>    //  specific messages to do this for each node type. Node that this lets you pass namespaces as a separate
67846>>>>>>>>>    //  parameter. With all of the other messages (e.g. createElementNode) you pass namespaces as prefixed to
67846>>>>>>>>>    // the tagname (e.g. Get CreateElementNode "MyNameSpace:MyTag" "MyValue" to hoEle)
67846>>>>>>>>>    
67846>>>>>>>>>    Function CreateChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
67848>>>>>>>>>        Handle hoNewNode hoDocumentObject
67848>>>>>>>>>        Handle infcNewNode
67848>>>>>>>>>        Integer iClassid iType
67848>>>>>>>>>        Get DocumentObject to hoDocumentObject
67849>>>>>>>>>        Get NodeClassId iNodeType to iClassId
67850>>>>>>>>>        If (iClassId<>0) Begin
67852>>>>>>>>>            // Create a node in the document and assign its interface to the new DF object.
67852>>>>>>>>>            Get createNode of hoDocumentObject iNodeType sTagName sNameSpace to infcNewNode
67853>>>>>>>>>            // this is required to force the interface type to be correct.
67853>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, infcNewNode, 0, 0, 0, 0)) to iType
67854>>>>>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, infcNewNode, iType, 1, 0, 0)) to infcNewNode
67855>>>>>>>>>            
67855>>>>>>>>>            If infcNewNode ;                Get CreateXMLObject iClassId infcNewNode to hoNewNode
67858>>>>>>>>>        End
67858>>>>>>>>>>
67858>>>>>>>>>        Function_Return hoNewNode
67859>>>>>>>>>    End_Function
67860>>>>>>>>>    
67860>>>>>>>>>    
67860>>>>>>>>>    
67860>>>>>>>>>    // The Addxxxxx messages create a new node and appends it to the list. When used as a function,
67860>>>>>>>>>    // the object handle is returned and must be disposed of later by the programmer.
67860>>>>>>>>>    // When used as a procedure, the object is destroyed--it just does it and is done.
67860>>>>>>>>>    
67860>>>>>>>>>    Function AddElement String sTagName String sValue Returns Handle
67862>>>>>>>>>        Handle hoNewElement
67862>>>>>>>>>        Get CreateElementNode sTagName sValue to hoNewElement
67863>>>>>>>>>        If hoNewElement ;            Get AppendNode hoNewElement to hoNewElement
67866>>>>>>>>>        Function_Return hoNewElement
67867>>>>>>>>>    End_Function
67868>>>>>>>>>    
67868>>>>>>>>>    Procedure AddElement String sTagName String sValue
67870>>>>>>>>>        Handle hoNewElement
67870>>>>>>>>>        Get AddElement sTagName sValue to hoNewElement
67871>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
67874>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElement"))
67876>>>>>>>>>    End_Procedure
67877>>>>>>>>>    
67877>>>>>>>>>    // this returns the object, This is often needed
67877>>>>>>>>>    Function CreateElementNodeNS String sNameSpace String sTagName String sValue Returns Handle
67879>>>>>>>>>        Handle hoNewElement
67879>>>>>>>>>        Get CreateChildNode NODE_ELEMENT sTagName sNameSpace to hoNewElement
67880>>>>>>>>>        If (hoNewElement and sValue<>"") ;            Set psText of hoNewElement to sValue
67883>>>>>>>>>        Function_Return hoNewElement
67884>>>>>>>>>    End_Function
67885>>>>>>>>>    
67885>>>>>>>>>    
67885>>>>>>>>>    // this returns the object, This is often needed
67885>>>>>>>>>    Function AddElementNS String sNameSpace String sTagName String sValue Returns Handle
67887>>>>>>>>>        Handle hoNewElement
67887>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName sValue to hoNewElement
67888>>>>>>>>>        If hoNewElement Begin
67890>>>>>>>>>            Get AppendNode hoNewElement to hoNewElement
67891>>>>>>>>>        End
67891>>>>>>>>>>
67891>>>>>>>>>        Function_Return hoNewElement
67892>>>>>>>>>    End_Function
67893>>>>>>>>>    
67893>>>>>>>>>    Procedure AddElementNS String sNameSpace String sTagName String sValue
67895>>>>>>>>>        Handle hoNewElement
67895>>>>>>>>>        Get AddElementNS sNameSpace sTagName sValue to hoNewElement
67896>>>>>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
67899>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElementNS"))
67901>>>>>>>>>    End_Procedure
67902>>>>>>>>>    
67902>>>>>>>>>    Function AddAttributeNode Handle hoNode Returns Handle
67904>>>>>>>>>        Handle hInfc
67904>>>>>>>>>        Get Set_AttributeNode (XmlInterface(hoNode)) to hInfc
67905>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Set XmlInterface of hoNode to hInfc
67908>>>>>>>>>        Function_Return hoNode
67909>>>>>>>>>    End_Function
67910>>>>>>>>>    
67910>>>>>>>>>    Function AttributeValueNode String sName Returns Handle
67912>>>>>>>>>        Handle hInfc
67912>>>>>>>>>        Handle hoNode
67912>>>>>>>>>        Get AttributeNode sName to hInfc
67913>>>>>>>>>        If hInfc ; // if ret value we have a replacement            Get CreateXMLNode hInfc to hoNode
67916>>>>>>>>>        Function_Return hoNode
67917>>>>>>>>>    End_Function
67918>>>>>>>>>    
67918>>>>>>>>>    Function AttributeValueNodeNS String sNameSpace String sBaseName Returns Handle
67920>>>>>>>>>        Handle hoAttrs hoAttr
67920>>>>>>>>>        String sValue
67920>>>>>>>>>        Get TempAttributeNodes to hoAttrs
67921>>>>>>>>>        If hoAttrs Begin
67923>>>>>>>>>            Get QualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
67924>>>>>>>>>            Set XMLInterface of hoAttrs to 0
67925>>>>>>>>>        End
67925>>>>>>>>>>
67925>>>>>>>>>        Function_Return hoAttr
67926>>>>>>>>>    End_Function
67927>>>>>>>>>    
67927>>>>>>>>>    
67927>>>>>>>>>    Function CreateAttributeNodeNS String sNameSpace String sName String sValue Returns Handle
67929>>>>>>>>>        Handle hoNewAttribute
67929>>>>>>>>>        Get CreateChildNode NODE_ATTRIBUTE sName sNameSpace to hoNewAttribute
67930>>>>>>>>>        If hoNewAttribute ;            Set psText of hoNewAttribute to sValue
67933>>>>>>>>>        Function_Return hoNewAttribute
67934>>>>>>>>>    End_Function
67935>>>>>>>>>    
67935>>>>>>>>>    Procedure AddAttributeNS String sNameSpace String sName String sValue
67937>>>>>>>>>        Handle hoNode
67937>>>>>>>>>        Get CreateAttributeNodeNS sNameSpace sName sValue to hoNode
67938>>>>>>>>>        If hoNode Begin
67940>>>>>>>>>            Get AddAttributeNode hoNode to hoNode
67941>>>>>>>>>            If hoNode ;                Send Destroy of hoNode
67944>>>>>>>>>        End
67944>>>>>>>>>>
67944>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddAttributeNS"))
67946>>>>>>>>>    End_Procedure
67947>>>>>>>>>    
67947>>>>>>>>>    
67947>>>>>>>>>    // This function encapsulates creation and addition of attributes to a node.
67947>>>>>>>>>    // should only work with element class
67947>>>>>>>>>    Procedure AddAttribute String sName String sValue
67949>>>>>>>>>        Set AttributeValue sName to sValue
67950>>>>>>>>>    End_Procedure
67951>>>>>>>>>    
67951>>>>>>>>>    // This function encapsulates creation and addition of comments to a node.
67951>>>>>>>>>    // The return value is a Boolean that is currently unused.
67951>>>>>>>>>    
67951>>>>>>>>>    Procedure AddChildComment String sValue
67953>>>>>>>>>        Handle hoNewNode
67953>>>>>>>>>        Get createChildComment sValue to hoNewNode
67954>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildComment"))
67957>>>>>>>>>        Else Begin
67958>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
67959>>>>>>>>>            Send Destroy to hoNewNode
67960>>>>>>>>>        End
67960>>>>>>>>>>
67960>>>>>>>>>    End_Procedure
67961>>>>>>>>>    
67961>>>>>>>>>    // This function encapsulates creation and addition of processing instructions to a node.
67961>>>>>>>>>    // The return value is a Boolean that is currently unused.
67961>>>>>>>>>    
67961>>>>>>>>>    Procedure AddChildProcessingInstruction String sTarget String sValue
67963>>>>>>>>>        Handle hoNewNode
67963>>>>>>>>>        Get createChildProcessingInstruction sTarget sValue to hoNewNode
67964>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildProcessingInstruction"))
67967>>>>>>>>>        Else Begin
67968>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
67969>>>>>>>>>            Send Destroy to hoNewNode
67970>>>>>>>>>        End
67970>>>>>>>>>>
67970>>>>>>>>>    End_Procedure
67971>>>>>>>>>    
67971>>>>>>>>>    
67971>>>>>>>>>    // This function encapsulates creation and addition of text nodes to a node.
67971>>>>>>>>>    // The return value is a Boolean that is currently unused.
67971>>>>>>>>>    
67971>>>>>>>>>    Procedure AddChildTextNode String sValue
67973>>>>>>>>>        Handle hoNewNode
67973>>>>>>>>>        Get createChildTextNode sValue to hoNewNode
67974>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildTextNode"))
67977>>>>>>>>>        Else Begin
67978>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
67979>>>>>>>>>            Send Destroy to hoNewNode
67980>>>>>>>>>        End
67980>>>>>>>>>>
67980>>>>>>>>>    End_Procedure
67981>>>>>>>>>    
67981>>>>>>>>>    // This procedure encapsulates creation and addition of cdata text nodes to a node.
67981>>>>>>>>>    Procedure AddCDataSection String sValue
67983>>>>>>>>>        Handle hoNewNode
67983>>>>>>>>>        Get CreateCDATASectionNode sValue to hoNewNode
67984>>>>>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddCDataSection"))
67987>>>>>>>>>        Else Begin
67988>>>>>>>>>            Get AppendNode hoNewNode to hoNewNode
67989>>>>>>>>>            Send Destroy to hoNewNode
67990>>>>>>>>>        End
67990>>>>>>>>>>
67990>>>>>>>>>    End_Procedure
67991>>>>>>>>>    
67991>>>>>>>>>    
67991>>>>>>>>>    Function AddChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
67993>>>>>>>>>        Handle hoNewNode
67993>>>>>>>>>        Handle hoDocumentObject
67993>>>>>>>>>        Get DocumentObject to hoDocumentObject
67994>>>>>>>>>        Get createChildNode of hoDocumentObject iNodeType sTagName sNamespace to hoNewNode
67995>>>>>>>>>        If hoNewNode ;            Get AppendNode hoNewNode to hoNewNode
67998>>>>>>>>>        Function_Return hoNewNode
67999>>>>>>>>>    End_Function
68000>>>>>>>>>    
68000>>>>>>>>>    // don't use the runtime/msxml version of this. Instead just return the
68000>>>>>>>>>    // first text from the first child node. This is much faster
68000>>>>>>>>>    Function psText Returns String
68002>>>>>>>>>        Handle hText
68002>>>>>>>>>        String sValue
68002>>>>>>>>>        Get phFirstChild to hText
68003>>>>>>>>>        Get InfcNodeValue hText to sValue
68004>>>>>>>>>        Function_Return sValue
68005>>>>>>>>>    End_Function
68006>>>>>>>>>    
68006>>>>>>>>>    // Use this to call the internal Text property. This returns all text for all child
68006>>>>>>>>>    // node. You rarely would want to do this. The is uses the msxml psText which can
68006>>>>>>>>>    // get slow with very large files. If for some reason you need all of the child node's
68006>>>>>>>>>    // text and the file is large, you might want to consider doing this process manually.
68006>>>>>>>>>    Function AllChildNodesText Returns String
68008>>>>>>>>>        String sValue
68008>>>>>>>>>        Forward Get psText to sValue
68010>>>>>>>>>        Function_Return sValue
68011>>>>>>>>>    End_Function
68012>>>>>>>>>    
68012>>>>>>>>>    // return the interface NodeValue without having to create a
68012>>>>>>>>>    // new object. This also disposes the hInfc interface
68012>>>>>>>>>    Function InfcNodeValue Handle hInfc Returns String
68014>>>>>>>>>        Handle hoDocument hoTempNode
68014>>>>>>>>>        String sValue
68014>>>>>>>>>        If (hinfc) Begin
68016>>>>>>>>>            Get DocumentObject to hoDocument
68017>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
68018>>>>>>>>>            Set XMLInterface of hoTempNode to hInfc
68019>>>>>>>>>            Get psNodeValue of hoTempNode to sValue
68020>>>>>>>>>            // This disposes of hInfc which was passed in. After
68020>>>>>>>>>            // calling this you can no longer use it (which is good).
68020>>>>>>>>>            Set XMLInterface of hoTempNode to 0
68021>>>>>>>>>        End
68021>>>>>>>>>>
68021>>>>>>>>>        Function_Return sValue
68022>>>>>>>>>    End_Function
68023>>>>>>>>>    
68023>>>>>>>>>    // ChildNodeValue is used to get the "value" of an element. This is useful when the element
68023>>>>>>>>>    // only has a single value (similar to an attribute).
68023>>>>>>>>>    
68023>>>>>>>>>    Function ChildNodeValue String sTagName Returns String
68025>>>>>>>>>        Handle hoTempNode hoDocument
68025>>>>>>>>>        Handle hinfcTempNode
68025>>>>>>>>>        String sRetVal
68025>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
68026>>>>>>>>>        If (hinfcTempNode <> 0) Begin
68028>>>>>>>>>            Get DocumentObject to hoDocument
68029>>>>>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
68030>>>>>>>>>            Set XMLInterface of hoTempNode to hinfcTempNode
68031>>>>>>>>>            Get phFirstChild of hoTempNode to hinfcTempNode
68032>>>>>>>>>            Set XMLInterface of hoTempNode to 0
68033>>>>>>>>>            If hinfcTempNode Begin
68035>>>>>>>>>                Get InfcNodeValue hinfcTempNode to sRetVal
68036>>>>>>>>>            End
68036>>>>>>>>>>
68036>>>>>>>>>        End
68036>>>>>>>>>>
68036>>>>>>>>>        Function_Return sRetVal
68037>>>>>>>>>    End_Function
68038>>>>>>>>>    
68038>>>>>>>>>    // This simple function allows a parent to change the text of one of its elements.
68038>>>>>>>>>    // This actually occurs quite a bit, because (as stated above) lowest level
68038>>>>>>>>>    // elements are frequently used as properties.
68038>>>>>>>>>    //
68038>>>>>>>>>    Procedure SetChildNodeValue String sTagName String sValue
68040>>>>>>>>>        Handle hoTempNode
68040>>>>>>>>>        Handle hinfcTempNode
68040>>>>>>>>>        // Search for the node that matches.
68040>>>>>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
68041>>>>>>>>>        // If no match is found, add a new element with the tag.
68041>>>>>>>>>        If (hinfcTempNode = 0) ;            Send AddElement sTagName sValue
68044>>>>>>>>>        Else Begin
68045>>>>>>>>>            Get CreateXMLObject U_BaseXMLDOMNode hinfcTempNode to hoTempNode
68046>>>>>>>>>            If hoTempNode Begin
68048>>>>>>>>>                // Set the text of the element.
68048>>>>>>>>>                Set psText of hoTempNode to sValue
68049>>>>>>>>>                Send Destroy to hoTempNode
68050>>>>>>>>>            End
68050>>>>>>>>>>
68050>>>>>>>>>            Else ;                Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_SetChildNodeValue"))
68052>>>>>>>>>        End
68052>>>>>>>>>>
68052>>>>>>>>>    End_Procedure
68053>>>>>>>>>    
68053>>>>>>>>>    // These messages are used to allow you to travese through a nodes.
68053>>>>>>>>>    
68053>>>>>>>>>    Function FirstChild Returns Handle
68055>>>>>>>>>        Handle hoChild
68055>>>>>>>>>        Handle hinfcChild
68055>>>>>>>>>        Get phFirstChild  to hinfcChild
68056>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
68059>>>>>>>>>        Function_Return hoChild
68060>>>>>>>>>    End_Function
68061>>>>>>>>>    
68061>>>>>>>>>    Function NextSibling Returns Handle
68063>>>>>>>>>        Handle hoChild
68063>>>>>>>>>        Handle hinfcChild
68063>>>>>>>>>        Get phNextSibling  to hinfcChild
68064>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
68067>>>>>>>>>        Function_Return hoChild
68068>>>>>>>>>    End_Function
68069>>>>>>>>>    
68069>>>>>>>>>    Function PreviousSibling Returns Handle
68071>>>>>>>>>        Handle hoChild
68071>>>>>>>>>        Handle hinfcChild
68071>>>>>>>>>        Get phPreviousSibling  to hinfcChild
68072>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
68075>>>>>>>>>        Function_Return hoChild
68076>>>>>>>>>    End_Function
68077>>>>>>>>>    
68077>>>>>>>>>    Function LastChild Returns Handle
68079>>>>>>>>>        Handle hoChild
68079>>>>>>>>>        Handle hinfcChild
68079>>>>>>>>>        Get phLastChild  to hinfcChild
68080>>>>>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
68083>>>>>>>>>        Function_Return hoChild
68084>>>>>>>>>    End_Function
68085>>>>>>>>>    
68085>>>>>>>>>    // return an object that is the parent of the current node
68085>>>>>>>>>    Function ParentNode Returns Handle
68087>>>>>>>>>        Handle hoId
68087>>>>>>>>>        Handle hinfcXMLInterface
68087>>>>>>>>>        Get phParentNode to hinfcXMLInterface
68088>>>>>>>>>        If (hinfcXMLInterface) ;            Get CreateXmlNode hinfcXMLInterface to hoID
68091>>>>>>>>>        Function_Return hoID
68092>>>>>>>>>    End_Function
68093>>>>>>>>>    
68093>>>>>>>>>    // Same as NextSibling except it uses or destroys the current node
68093>>>>>>>>>    //
68093>>>>>>>>>    // optimized version does not destroy/create object unless it needs to.
68093>>>>>>>>>    // if the next node is the same node type we will resuse this object
68093>>>>>>>>>    // else this object is destroyed
68093>>>>>>>>>    Function NextNode Returns Handle
68095>>>>>>>>>        Handle hoNode hoDocument
68095>>>>>>>>>        Handle hInfc
68095>>>>>>>>>        Get phNextSibling to hInfc
68096>>>>>>>>>        If hInfc Begin
68098>>>>>>>>>            Get DocumentObject to hoDocument
68099>>>>>>>>>            Move Self to hoNode
68100>>>>>>>>>            Send BindXMLInfc of hoDocument hInfc (&hoNode)
68101>>>>>>>>>        End
68101>>>>>>>>>>
68101>>>>>>>>>        Else Begin
68102>>>>>>>>>            Send Destroy
68103>>>>>>>>>            Move 0 to hoNode
68104>>>>>>>>>        End
68104>>>>>>>>>>
68104>>>>>>>>>        Function_Return hoNode
68105>>>>>>>>>    End_Function
68106>>>>>>>>>    
68106>>>>>>>>>    
68106>>>>>>>>>    // Enumerate through all nodes.
68106>>>>>>>>>    
68106>>>>>>>>>    Procedure EnumerateNodes Integer iMsg Handle hoReceiver String sVal1 String sVal2
68108>>>>>>>>>        Integer i iLen
68108>>>>>>>>>        Handle hoNode
68108>>>>>>>>>        Handle hoNodeCollection
68108>>>>>>>>>        Get ChildNodes to hoNodeCollection
68109>>>>>>>>>        If (hoNodeCollection <> 0) Begin
68111>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
68112>>>>>>>>>            Decrement iLen
68113>>>>>>>>>            For i from 0 to iLen
68119>>>>>>>>>>
68119>>>>>>>>>                // For each record, process its fields.
68119>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
68120>>>>>>>>>                Send iMsg of hoReceiver hoNode sVal1 sVal2
68121>>>>>>>>>                Send Destroy of hoNode
68122>>>>>>>>>            Loop
68123>>>>>>>>>>
68123>>>>>>>>>            Send Destroy of hoNodeCollection
68124>>>>>>>>>        End
68124>>>>>>>>>>
68124>>>>>>>>>    End_Procedure
68125>>>>>>>>>    
68125>>>>>>>>>    // Enumerate through all elements.
68125>>>>>>>>>    
68125>>>>>>>>>    Procedure EnumerateElements Integer iMsg Handle hoReceiver String sVal1 String sVal2
68127>>>>>>>>>        Integer i iLen
68127>>>>>>>>>        Handle hoNode
68127>>>>>>>>>        Handle hoNodeCollection
68127>>>>>>>>>        Get ChildNodes to hoNodeCollection
68128>>>>>>>>>        If (hoNodeCollection <> 0) Begin
68130>>>>>>>>>            Get NodeListLength of hoNodeCollection to iLen
68131>>>>>>>>>            Decrement iLen
68132>>>>>>>>>            For i from 0 to iLen
68138>>>>>>>>>>
68138>>>>>>>>>                // For each record, process its fields.
68138>>>>>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
68139>>>>>>>>>                If (piNodeType(hoNode)=NODE_ELEMENT) ;                    Send iMsg of hoReceiver hoNode sVal1 sVal2
68142>>>>>>>>>                Send Destroy of hoNode
68143>>>>>>>>>            Loop
68144>>>>>>>>>>
68144>>>>>>>>>            Send Destroy of hoNodeCollection
68145>>>>>>>>>        End
68145>>>>>>>>>>
68145>>>>>>>>>    End_Procedure
68146>>>>>>>>>    
68146>>>>>>>>>    
68146>>>>>>>>>    // enumerate through all attributes. There is no recurse here because attributes will not
68146>>>>>>>>>    // contain attributes.
68146>>>>>>>>>    
68146>>>>>>>>>    Procedure EnumerateAttributes Integer iMsg Handle hoReceiver String sSomeValue
68148>>>>>>>>>        Integer i iLen
68148>>>>>>>>>        Handle hoNode
68148>>>>>>>>>        Handle hoNodeMapCollection
68148>>>>>>>>>        // we don't use tempattributenodes because we don't know what the enum message will do.
68148>>>>>>>>>        Get AttributeNodes to hoNodeMapCollection
68149>>>>>>>>>        If (hoNodeMapCollection <> 0) Begin
68151>>>>>>>>>            Get NodeListLength of hoNodeMapCollection to iLen
68152>>>>>>>>>            Decrement iLen
68153>>>>>>>>>            For i from 0 to iLen
68159>>>>>>>>>>
68159>>>>>>>>>                // For each record, process its fields.
68159>>>>>>>>>                Get CollectionNode of hoNodeMapCollection i to hoNode
68160>>>>>>>>>                Send iMsg of hoReceiver hoNode sSomeValue
68161>>>>>>>>>                Send Destroy of hoNode
68162>>>>>>>>>            Loop
68163>>>>>>>>>>
68163>>>>>>>>>            Send Destroy of hoNodeMapCollection
68164>>>>>>>>>        End
68164>>>>>>>>>>
68164>>>>>>>>>    End_Procedure
68165>>>>>>>>>    
68165>>>>>>>>>    
68165>>>>>>>>>    Function XSLTransformation Handle hoXSLDocument Returns String
68167>>>>>>>>>        Handle infcXSLStartAt
68167>>>>>>>>>        String sBuffer
68167>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
68167>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
68168>>>>>>>>>        Get TransformNode infcXSLStartAt to sBuffer
68169>>>>>>>>>        Function_Return sBuffer
68170>>>>>>>>>    End_Function
68171>>>>>>>>>    
68171>>>>>>>>>    // This allows for transformations not limited to the size of the string buffer
68171>>>>>>>>>    //
68171>>>>>>>>>    // Note that it is up to the programmer to dispose of the memory allocated at pBuffer
68171>>>>>>>>>    // by using the free(pBuffer) function
68171>>>>>>>>>    //
68171>>>>>>>>>    Function XSLTransformationToAddress Handle hoXSLDocument Returns Address
68173>>>>>>>>>        Handle infcXSLStartAt
68173>>>>>>>>>        Address pBuffer
68173>>>>>>>>>        // Transformation is of current object using passed XSLDocument.
68173>>>>>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
68174>>>>>>>>>        Get TransformNodeToAddress infcXSLStartAt to pBuffer
68175>>>>>>>>>        Function_Return pBuffer
68176>>>>>>>>>    End_Function
68177>>>>>>>>>    
68177>>>>>>>>>    
68177>>>>>>>>>    // extract base name from string. e.g.: ns:name --> name
68177>>>>>>>>>    //
68177>>>>>>>>>    Function BaseNameFromQName String sName Returns String
68179>>>>>>>>>        Integer iPos
68179>>>>>>>>>        Move (Pos(":",sName)) to iPos
68180>>>>>>>>>        If iPos Begin
68182>>>>>>>>>            Move (remove(sName,1,iPos)) to sName
68183>>>>>>>>>        End
68183>>>>>>>>>>
68183>>>>>>>>>        Function_Return sName
68184>>>>>>>>>    End_Function
68185>>>>>>>>>    
68185>>>>>>>>>    // extract prefix name from string. e.g.: ns:name --> ns
68185>>>>>>>>>    //
68185>>>>>>>>>    Function PrefixNameFromQName String sName Returns String
68187>>>>>>>>>        String sPreFix
68187>>>>>>>>>        Integer iPos
68187>>>>>>>>>        Move (Pos(":",sName)) to iPos
68188>>>>>>>>>        If iPos Begin
68190>>>>>>>>>            Move (Left(sName,iPos-1)) to sPreFix
68191>>>>>>>>>        End
68191>>>>>>>>>>
68191>>>>>>>>>        Function_Return sPreFix
68192>>>>>>>>>    End_Function
68193>>>>>>>>>    
68193>>>>>>>>>    
68193>>>>>>>>>    // Returns true if node is element and namespace and base name match
68193>>>>>>>>>    //
68193>>>>>>>>>    Function IsElementNS String sNamespaceURI String sBaseName Returns Boolean
68195>>>>>>>>>        Function_Return (piNodeType(Self)=NODE_ELEMENT and ;            psNameSpaceURI(Self)=sNamespaceURI and ;            psBaseName(Self)=sBaseName )
68196>>>>>>>>>    End_Function
68197>>>>>>>>>    
68197>>>>>>>>>    // Returns node of first occurence of child node matching namespace and base name
68197>>>>>>>>>    //
68197>>>>>>>>>    Function ChildElementNS String sNameSpaceURI String sBaseName Returns Handle
68199>>>>>>>>>        Handle hoNode
68199>>>>>>>>>        Get FirstChild to hoNode
68200>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
68204>>>>>>>>>            Get NextNode of hoNode to hoNode
68205>>>>>>>>>        Loop
68206>>>>>>>>>>
68206>>>>>>>>>        Function_Return hoNode
68207>>>>>>>>>    End_Function
68208>>>>>>>>>    
68208>>>>>>>>>    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
68210>>>>>>>>>        Handle hoNode
68210>>>>>>>>>        // NextNode may return the same object or it may destroy the object and
68210>>>>>>>>>        // return nothing or a different object
68210>>>>>>>>>        Get NextNode to hoNode
68211>>>>>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
68215>>>>>>>>>            // use of hoNode is required. This can be different than self
68215>>>>>>>>>            Get NextNode of hoNode to hoNode
68216>>>>>>>>>        Loop
68217>>>>>>>>>>
68217>>>>>>>>>        
68217>>>>>>>>>        Function_Return hoNode
68218>>>>>>>>>    End_Function
68219>>>>>>>>>    
68219>>>>>>>>>    
68219>>>>>>>>>    // Returns value (string) first occurence of child node matching namespace and base name
68219>>>>>>>>>    //
68219>>>>>>>>>    Function ChildElementValueNS String sNameSpaceURI String sBaseName Returns String
68221>>>>>>>>>        Handle hoNext
68221>>>>>>>>>        String sText
68221>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNext
68222>>>>>>>>>        If hoNext Begin
68224>>>>>>>>>            Get psText of hoNext to sText
68225>>>>>>>>>            Send destroy of hoNext
68226>>>>>>>>>        End
68226>>>>>>>>>>
68226>>>>>>>>>        Function_Return sText
68227>>>>>>>>>    End_Function
68228>>>>>>>>>    
68228>>>>>>>>>    Procedure SetChildElementValueNS String sNameSpaceURI String sBaseName String sValue
68230>>>>>>>>>        Handle hoNode
68230>>>>>>>>>        Handle hinfcTempNode
68230>>>>>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNode
68231>>>>>>>>>        If (hoNode=0) Begin
68233>>>>>>>>>            Send AddElementNS sNameSpaceURI sBaseName sValue
68234>>>>>>>>>        End
68234>>>>>>>>>>
68234>>>>>>>>>        Else Begin
68235>>>>>>>>>            Set psText of hoNode to sValue
68236>>>>>>>>>            Send destroy of hoNode
68237>>>>>>>>>        End
68237>>>>>>>>>>
68237>>>>>>>>>    End_Procedure
68238>>>>>>>>>    
68238>>>>>>>>>    // pass a prefix and try to finds its NameSpaceURI. Start at current node and work up to parent.
68238>>>>>>>>>    // This can be useful when a qualified name is found in an attribute value
68238>>>>>>>>>    //
68238>>>>>>>>>    Function PrefixToNamespaceURI String sPrefix Returns String
68240>>>>>>>>>        Handle hoNode
68240>>>>>>>>>        Integer i iNodes
68240>>>>>>>>>        Handle hoNodes hoParentNode hoAttNode
68240>>>>>>>>>        Boolean bDone bParent
68240>>>>>>>>>        String sAttPrefix sName sNameSpace
68240>>>>>>>>>        
68240>>>>>>>>>        Move Self to hoNode
68241>>>>>>>>>        While not bDone
68245>>>>>>>>>            Get TempAttributeNodes of hoNode to hoNodes
68246>>>>>>>>>            If (hoNodes <> 0) Begin
68248>>>>>>>>>                Get NodeListLength of hoNodes to iNodes
68249>>>>>>>>>                For i from 0 to (iNodes-1)
68255>>>>>>>>>>
68255>>>>>>>>>                    // For each record, process its fields.
68255>>>>>>>>>                    Get CollectionNode of hoNodes i to hoAttNode
68256>>>>>>>>>                    Get psPrefix of hoAttNode to sAttPrefix
68257>>>>>>>>>                    Get psBaseName of hoAttNode to sName
68258>>>>>>>>>                    // with legacy msxml, xmlns="foo" returns psPrefix="xmlns" and pbBaseName=""
68258>>>>>>>>>                    // with newer msxml, xmlns="foo" returns psPrefix="" and pbBaseName="xmlns"
68258>>>>>>>>>                    // We handle both cases here.
68258>>>>>>>>>                    
68258>>>>>>>>>                    If ( (sAttPrefix="xmlns" and sName=sPrefix) or ; // if a normal xmlns:xx="foo" match (sPrefix="xx") or a legacy xmlns="foo" match (sPrefix="")                        (sPrefix="" and sAttPrefix="" and sName="xmlns") ) Begin // special test for newer msxml xmlns="foo" match (sPrefix="")
68260>>>>>>>>>                        
68260>>>>>>>>>                        Get Value of hoAttNode to sNameSpace
68261>>>>>>>>>                        Move True to bDone
68262>>>>>>>>>                        Move (iNodes-1) to i
68263>>>>>>>>>                        
68263>>>>>>>>>                    End
68263>>>>>>>>>>
68263>>>>>>>>>                    
68263>>>>>>>>>                    Send Destroy of hoAttNode
68264>>>>>>>>>                Loop
68265>>>>>>>>>>
68265>>>>>>>>>                Set XMLInterface of hoNodes to 0
68266>>>>>>>>>            End
68266>>>>>>>>>>
68266>>>>>>>>>            
68266>>>>>>>>>            Get ParentNode of hoNode to hoParentNode
68267>>>>>>>>>            If bParent ;                Send destroy of hoNode
68270>>>>>>>>>            If not bDone Begin
68272>>>>>>>>>                If not hoParentNode ;                    Move True to bDone
68275>>>>>>>>>                Else Begin
68276>>>>>>>>>                    Move True to bParent
68277>>>>>>>>>                    Move hoParentNode to hoNode
68278>>>>>>>>>                End
68278>>>>>>>>>>
68278>>>>>>>>>            End
68278>>>>>>>>>>
68278>>>>>>>>>        Loop
68279>>>>>>>>>>
68279>>>>>>>>>        Function_Return sNameSpace
68280>>>>>>>>>    End_Function
68281>>>>>>>>>    
68281>>>>>>>>>    
68281>>>>>>>>>    
68281>>>>>>>>>End_Class
68282>>>>>>>>>
68282>>>>>>>>>// Set up basic inheritance for specialized forms of XML classes.
68282>>>>>>>>>// This needs to be done so we can make objects of these types.
68282>>>>>>>>>
68282>>>>>>>>>Class cXMLDOMElement is a BaseXmlDomElement
68283>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68284>>>>>>>>>    
68284>>>>>>>>>    // Should use AddAttributeValue...does same thing
68284>>>>>>>>>    Procedure SetAttributeValue String sName String sValue
68286>>>>>>>>>        Send AddAttribute sName sValue
68287>>>>>>>>>    End_Procedure
68288>>>>>>>>>    
68288>>>>>>>>>    // Note: Get_AttributeValue already there
68288>>>>>>>>>    
68288>>>>>>>>>    Procedure RemoveAttribute String sName
68290>>>>>>>>>        Integer iVal
68290>>>>>>>>>        Get RemoveAttribute sName to iVal
68291>>>>>>>>>    End_Procedure
68292>>>>>>>>>    
68292>>>>>>>>>    Function AttributeValueNS String sNameSpace String sBaseName Returns String
68294>>>>>>>>>        String sValue
68294>>>>>>>>>        Handle hinfcItem
68294>>>>>>>>>        Handle hoDoc hoTempAttributeNodes hoNode
68294>>>>>>>>>        Integer hinfcAttributes
68294>>>>>>>>>        
68294>>>>>>>>>        Get TempAttributeNodes to hoTempAttributeNodes
68295>>>>>>>>>        Get QualifiedItem of hoTempAttributeNodes sBaseName sNameSpace  to hinfcItem
68296>>>>>>>>>        Set XMLInterface of hoTempAttributeNodes to 0
68297>>>>>>>>>        If hinfcItem Begin
68299>>>>>>>>>            Get DocumentObject to hoDoc
68300>>>>>>>>>            Get phoTempDomNode of hoDoc to hoNode
68301>>>>>>>>>            Set XMLInterface of hoNode to hinfcItem
68302>>>>>>>>>            Get psNodeValue of hoNode to sValue
68303>>>>>>>>>            Set XMLInterface of hoNode to 0
68304>>>>>>>>>        End
68304>>>>>>>>>>
68304>>>>>>>>>        Function_Return sValue
68305>>>>>>>>>    End_Function
68306>>>>>>>>>    
68306>>>>>>>>>    Procedure RemoveAttributeNS String sNameSpace String sBaseName
68308>>>>>>>>>        Handle hoAttrs hoAttr
68308>>>>>>>>>        String sValue
68308>>>>>>>>>        Get TempAttributeNodes to hoAttrs
68309>>>>>>>>>        If hoAttrs Begin
68311>>>>>>>>>            Get RemoveQualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
68312>>>>>>>>>            Set XMLInterface of hoAttrs to 0
68313>>>>>>>>>            If hoAttr ;                Send destroy of hoAttr
68316>>>>>>>>>        End
68316>>>>>>>>>>
68316>>>>>>>>>    End_Procedure
68317>>>>>>>>>    
68317>>>>>>>>>End_Class
68318>>>>>>>>>
68318>>>>>>>>>Class cXMLDOMNode is a BaseXmlDomNode
68319>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68320>>>>>>>>>End_Class
68321>>>>>>>>>
68321>>>>>>>>>Class cXMLDOMAttribute is a BaseXmlDomAttribute
68322>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68323>>>>>>>>>End_Class
68324>>>>>>>>>
68324>>>>>>>>>Class cXMLDOMComment is a BaseXmlDomComment
68325>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68326>>>>>>>>>End_Class
68327>>>>>>>>>
68327>>>>>>>>>Class cXMLDOMProcessingInstruction is a BaseXmlDomProcessingInstruction
68328>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68329>>>>>>>>>End_Class
68330>>>>>>>>>
68330>>>>>>>>>Class cXMLDOMTextNode is a BaseXmlDomTextNode
68331>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68332>>>>>>>>>End_Class
68333>>>>>>>>>
68333>>>>>>>>>Class cXMLDOMCDATASection is a BaseXmlDomCDATASection
68334>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68335>>>>>>>>>End_Class
68336>>>>>>>>>
68336>>>>>>>>>Class cXMLDOMDocumentType is a BaseXmlDomDocumentType
68337>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68338>>>>>>>>>    
68338>>>>>>>>>End_Class
68339>>>>>>>>>
68339>>>>>>>>>Class cXMLDOMNotation is a BaseXmlDomNotation
68340>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68341>>>>>>>>>End_Class
68342>>>>>>>>>
68342>>>>>>>>>Class cXMLDOMEntity is a BaseXmlDomEntity
68343>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68344>>>>>>>>>End_Class
68345>>>>>>>>>
68345>>>>>>>>>Class cXMLDOMEntityReference is a BaseXmlDomEntityReference
68346>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68347>>>>>>>>>End_Class
68348>>>>>>>>>
68348>>>>>>>>>Class cXMLDOMDocumentFragment is a BaseXmlDomDocumentFragment
68349>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68350>>>>>>>>>End_Class
68351>>>>>>>>>
68351>>>>>>>>>
68351>>>>>>>>>Class cXMLDOMParseError is a BaseXMLDomParseError
68352>>>>>>>>>    // returns an error sub-object as a sibling of this error object
68352>>>>>>>>>    Function ErrorItemNode Integer iItem Returns Handle
68354>>>>>>>>>        Handle hoParseErrorNode hoParent
68354>>>>>>>>>        Handle hParseErrorIntf
68354>>>>>>>>>        Get ErrorItem iItem to hParseErrorIntf
68355>>>>>>>>>        If (hParseErrorIntf) Begin
68357>>>>>>>>>            // add to parent in case developer destroys the current object
68357>>>>>>>>>            Get Parent to hoParent
68358>>>>>>>>>            Get Create of hoParent U_cXMLDOMParseError to hoParseErrorNode
68359>>>>>>>>>            Set XmlInterface of hoParseErrorNode to hParseErrorIntf
68360>>>>>>>>>        End
68360>>>>>>>>>>
68360>>>>>>>>>        Function_Return hoParseErrorNode
68361>>>>>>>>>    End_Function
68362>>>>>>>>>End_Class
68363>>>>>>>>>
68363>>>>>>>>>// Base document class with Base functions.
68363>>>>>>>>>
68363>>>>>>>>>Class cXMLDOMDocument is an BaseXmlDomDocument
68364>>>>>>>>>    
68364>>>>>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
68365>>>>>>>>>    
68365>>>>>>>>>    Procedure Construct_Object
68367>>>>>>>>>        Handle hInfc
68367>>>>>>>>>        Forward Send Construct_Object
68369>>>>>>>>>        Property String psDocumentName ""
68370>>>>>>>>>        Property Integer phPrivateDocumentElement 0
68371>>>>>>>>>        Property Handle phoTempDomNode (Create(Self,U_cXMLDomNode))
68372>>>>>>>>>        Property Handle phoTempDomNodeMap (Create(Self,U_cXMLDOMNamedNodeMap))
68373>>>>>>>>>        
68373>>>>>>>>>        // added in 15.1. If no COM pointer, msxml6 is most likely not installed. This will
68373>>>>>>>>>        // raise an unhandled error, which could be augmented to do something else.
68373>>>>>>>>>        Get XmlInterface to hInfc
68374>>>>>>>>>        If (hInfc=0) Begin
68376>>>>>>>>>            Send ErrorCreatingXMLObject
68377>>>>>>>>>        End
68377>>>>>>>>>>
68377>>>>>>>>>        
68377>>>>>>>>>        // as of 18.0 pbAsync now defaults to False. In most cases, this is what you want
68377>>>>>>>>>        Set pbAsync to False
68378>>>>>>>>>    End_Procedure
68379>>>>>>>>>    
68379>>>>>>>>>    // returns the classId for the passed NodeType. This is a good augmentation point. All nodes
68379>>>>>>>>>    // within an xml document come here to get a class. So, if you want to augment and return a
68379>>>>>>>>>    // different class, just check the node type and return whatever -- else forward
68379>>>>>>>>>    
68379>>>>>>>>>    Function NodeClassId Integer iType Returns Integer
68381>>>>>>>>>        Integer iClassId
68381>>>>>>>>>        Case Begin
68381>>>>>>>>>            Case (iType=NODE_ELEMENT) ;                Move U_cXMLDOMElement      to iClassId
68384>>>>>>>>>            Case (iType=NODE_ATTRIBUTE) ;                Move U_cXMLDOMAttribute    to iClassId
68388>>>>>>>>>            Case (iType=NODE_TEXT) ;                Move U_cXMLDOMTextNode     to iClassId
68392>>>>>>>>>            Case (iType=NODE_CDATA_SECTION) ;                Move U_cXMLDOMCDATASection to iClassId
68396>>>>>>>>>            Case (iType=NODE_ENTITY_REFERENCE) ;                Move U_cXMLDOMEntityReference to iClassId
68400>>>>>>>>>            Case (iType=NODE_ENTITY) ;                Move U_cXMLDOMEntity       to iClassId
68404>>>>>>>>>            Case (iType=NODE_PROCESSING_INSTRUCTION) ;                Move U_cXMLDOMProcessingInstruction to iClassId
68408>>>>>>>>>            Case (iType=NODE_COMMENT) ;                Move U_cXMLDOMComment      to iClassId
68412>>>>>>>>>            Case (iType=NODE_DOCUMENT) ;                Move U_cXMLDOMDocument     to iClassId
68416>>>>>>>>>            Case (iType=NODE_DOCUMENT_TYPE) ;                Move U_cXMLDOMDocumentType to iClassId
68420>>>>>>>>>            Case (iType=NODE_DOCUMENT_FRAGMENT) ;                Move U_cXMLDOMDocumentFragment to iClassId
68424>>>>>>>>>            Case (iType=NODE_NOTATION) ;                Move U_cXMLDOMNotation     to iClassId
68428>>>>>>>>>            Case (iType=0) ;                Move 0                     to iClassId // this is an error!!
68432>>>>>>>>>            Case Else ;                Move U_cXMLDOMNode         to iClassId
68434>>>>>>>>>        Case End
68434>>>>>>>>>        Function_Return iClassId
68435>>>>>>>>>    End_Function
68436>>>>>>>>>    
68436>>>>>>>>>    // Load an XML Document. The name of the document is stored in a property
68436>>>>>>>>>    // that must be set for this function to work correctly.
68436>>>>>>>>>    
68436>>>>>>>>>    Function LoadXMLDocument Returns Integer
68438>>>>>>>>>        String sDocumentName
68438>>>>>>>>>        Integer bRetVal
68438>>>>>>>>>        Get psDocumentName to sDocumentName
68439>>>>>>>>>        Get LoadDocument sDocumentName to bRetVal
68440>>>>>>>>>        If (bRetVal = 0);            Function_Return True
68443>>>>>>>>>        Else;            Function_Return False
68445>>>>>>>>>    End_Function
68446>>>>>>>>>    
68446>>>>>>>>>    Function SaveXMLDocument Returns Integer
68448>>>>>>>>>        String sDocumentName
68448>>>>>>>>>        Integer bRetVal
68448>>>>>>>>>        Get psDocumentName to sDocumentName
68449>>>>>>>>>        Get SaveDocument sDocumentName to bRetVal
68450>>>>>>>>>        Function_Return bRetVal
68451>>>>>>>>>    End_Function
68452>>>>>>>>>    
68452>>>>>>>>>    // Load an XML from a string. This aguments the C message to ret 1 if Ok and 0 if error.
68452>>>>>>>>>    //
68452>>>>>>>>>    Function LoadXML String sXML Returns Integer
68454>>>>>>>>>        Integer bRetVal
68454>>>>>>>>>        // for some reason the parser will not work properly with embedded double quotes.
68454>>>>>>>>>        // Change all " to ' in document.
68454>>>>>>>>>        //Move (replaces('"',sXML,"'")) to sXML  // removed this. Bad Idea.
68454>>>>>>>>>        Forward Get LoadXml sXML to bRetVal
68456>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
68459>>>>>>>>>        Else;            Function_Return False
68461>>>>>>>>>    End_Function
68462>>>>>>>>>    
68462>>>>>>>>>    // Load an XML string from an address. This aguments the C message to ret 1 if Ok and 0 if error.
68462>>>>>>>>>    //
68462>>>>>>>>>    Function LoadXMLFromAddress Address pXML Returns Integer
68464>>>>>>>>>        Integer bRetVal
68464>>>>>>>>>        Forward Get LoadXmlFromAddress pXML to bRetVal
68466>>>>>>>>>        If (bRetVal = 0) ;            Function_Return True
68469>>>>>>>>>        Else;            Function_Return False
68471>>>>>>>>>    End_Function
68472>>>>>>>>>    
68472>>>>>>>>>    
68472>>>>>>>>>    // Allow Nodes and Node node lists to get the parent document.
68472>>>>>>>>>    
68472>>>>>>>>>    Function DocumentObject Returns Handle
68474>>>>>>>>>        Function_Return Self
68475>>>>>>>>>    End_Function
68476>>>>>>>>>    
68476>>>>>>>>>    // Access to the root node allows for searches and iterations.
68476>>>>>>>>>    // The root node is a cNode.
68476>>>>>>>>>    
68476>>>>>>>>>    Function DocumentElement Returns Handle
68478>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
68478>>>>>>>>>        Handle infcNode   // XML Element Interface
68478>>>>>>>>>        Get phDocumentElement to infcNode
68479>>>>>>>>>        If infcNode Begin
68481>>>>>>>>>            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
68482>>>>>>>>>            Set phPrivateDocumentElement to hNewNode // we no longer use this at all
68483>>>>>>>>>        End
68483>>>>>>>>>>
68483>>>>>>>>>        Function_Return hNewNode
68484>>>>>>>>>    End_Function
68485>>>>>>>>>    
68485>>>>>>>>>    //  CreateRootNode is used to set up the first element in a document.
68485>>>>>>>>>    //  It should only be used when creating new files.
68485>>>>>>>>>    
68485>>>>>>>>>    Function CreateDocumentElement String sTagName Returns Handle
68487>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
68487>>>>>>>>>        Handle infcNode   // XML Element Interface
68487>>>>>>>>>        // Call XML to create an element in the document.
68487>>>>>>>>>        Get CreateElement sTagName to infcNode
68488>>>>>>>>>        // Tie the element interface to the DataFlex object.
68488>>>>>>>>>        If infcNode ;            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
68491>>>>>>>>>        // Call XML to set the root element of the document.
68491>>>>>>>>>        Set phDocumentElement to infcNode
68492>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
68493>>>>>>>>>        Function_Return hNewNode
68494>>>>>>>>>    End_Function
68495>>>>>>>>>    
68495>>>>>>>>>    Function CreateDocumentElementNS String sNamespace String sTagName Returns Handle
68497>>>>>>>>>        Handle hNewNode       // Object ID of Root Node
68497>>>>>>>>>        Handle infcNode iType  // XML Element Interface
68497>>>>>>>>>        Get CreateElementNodeNS sNameSpace sTagName "" to hNewNode
68498>>>>>>>>>        Get XmlInterface of hNewNode to infcNode
68499>>>>>>>>>        Set phDocumentElement to infcNode
68500>>>>>>>>>        Set phPrivateDocumentElement to hNewNode
68501>>>>>>>>>        Function_Return hNewNode
68502>>>>>>>>>    End_Function
68503>>>>>>>>>    
68503>>>>>>>>>    
68503>>>>>>>>>    
68503>>>>>>>>>    // return the DocType as a document-type object. Returns 0 if no dtd
68503>>>>>>>>>    // Access to information from the doc type object is limited. Use get psXML
68503>>>>>>>>>    Function DocTypeNode Returns Handle
68505>>>>>>>>>        Handle hinfcDocType hoDocType
68505>>>>>>>>>        Get phDocType to hinfcDocType
68506>>>>>>>>>        If hinfcDocType ;            Get CreateXMLObject U_cXMLDOMDocumentType hinfcDocType to hoDocType
68509>>>>>>>>>        Function_Return hoDocType
68510>>>>>>>>>    End_Function
68511>>>>>>>>>    
68511>>>>>>>>>    Function phXMLErrorObject Returns Handle
68513>>>>>>>>>        Handle hoParseErrorObject
68513>>>>>>>>>        Handle hInfcParseError
68513>>>>>>>>>        Get phParseError to hInfcParseError
68514>>>>>>>>>        If hInfcParseError ;            Get CreateXMLObject U_cXMLDOMParseError hinfcParseError to hoParseErrorObject
68517>>>>>>>>>        Function_Return hoParseErrorObject
68518>>>>>>>>>    End_Function
68519>>>>>>>>>    
68519>>>>>>>>>    //  The following procedure is meant to be overridden by one provided by the developer.
68519>>>>>>>>>    
68519>>>>>>>>>    Procedure BasicParseErrorReport
68521>>>>>>>>>        String sProblem
68521>>>>>>>>>        String sLinePosition
68521>>>>>>>>>        String sDescr
68521>>>>>>>>>        String sReason
68521>>>>>>>>>        String sSource
68521>>>>>>>>>        Handle hoParseErrorObject
68521>>>>>>>>>        Get phXMLErrorObject to hoParseErrorObject
68522>>>>>>>>>        If hoParseErrorObject Begin
68524>>>>>>>>>            Move (SFormat(C_$CannotLoad, psDocumentName(Self)) + "."+character(13)+character(10)) to sProblem
68525>>>>>>>>>            Move (SFormat(C_$ParsingError, piLine(hoParseErrorObject), piLinePos(hoParseErrorObject))) to sLinePosition
68526>>>>>>>>>            Move (sLinePosition +character(13)+character(10)) to sLinePosition
68527>>>>>>>>>            
68527>>>>>>>>>            Move (C_$Reason + ":" * (psReason(hoParseErrorObject))  +character(13)+character(10)) to sReason
68528>>>>>>>>>            Move (C_$Source + ":" * (psSrcText(hoParseErrorObject))) to sSource
68529>>>>>>>>>            Move (sProblem + sLinePosition + sReason + sSource) to sDescr
68530>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR sDescr
68531>>>>>>>>>>
68531>>>>>>>>>            Send Destroy of hoParseErrorObject
68532>>>>>>>>>        End
68532>>>>>>>>>>
68532>>>>>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR C_$NotCreatedParseObject
68534>>>>>>>>>    End_Procedure
68535>>>>>>>>>    
68535>>>>>>>>>    // bind an xml interface node to the passed XML object. If the
68535>>>>>>>>>    // object type is of the wrong type, we will destroy it and recreate it
68535>>>>>>>>>    // which is why hoNode is passed byRef.
68535>>>>>>>>>    // to use this you'd have to use the lower level private messages to get the
68535>>>>>>>>>    // xml interface handles and then bind them to an object. Just like in COM you could
68535>>>>>>>>>    // bind these to the same object, which might save some parsing time. This is made private
68535>>>>>>>>>    // because the time savings would probably be small and would not justify the extra
68535>>>>>>>>>    // complexity.
68535>>>>>>>>>    // It is a programming error to pass this a zero handle.
68535>>>>>>>>>    Procedure BindXMLInfc Handle hInfc Handle ByRef hoNode
68537>>>>>>>>>        Integer iType iClassId iType2
68537>>>>>>>>>        Get piNodeType of hoNode to iType2 // type of the DF XML object
68538>>>>>>>>>        
68538>>>>>>>>>        // Get the node type of the infc handle w/o creating a DF object
68538>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
68539>>>>>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
68540>>>>>>>>>        If (hinfc=0) Begin
68542>>>>>>>>>            // this should not happen and we would need to know about this.
68542>>>>>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
68543>>>>>>>>>>
68543>>>>>>>>>            Procedure_Return 0
68544>>>>>>>>>        End
68544>>>>>>>>>>
68544>>>>>>>>>        // if the type is the same we can reuse the current object and binding it to the interface pointer
68544>>>>>>>>>        If (iType=iType2) Begin
68546>>>>>>>>>            // resuse Self and return
68546>>>>>>>>>            Set XMLInterface of hoNode to hInfc
68547>>>>>>>>>        End
68547>>>>>>>>>>
68547>>>>>>>>>        // if diffrent type, destroy the existing object and recreate it
68547>>>>>>>>>        Else Begin
68548>>>>>>>>>            Send Destroy of hoNode
68549>>>>>>>>>            Get NodeClassId iType to iClassId
68550>>>>>>>>>            Get CreateXMLObject iClassId hInfc to hoNode
68551>>>>>>>>>        End
68551>>>>>>>>>>
68551>>>>>>>>>    End_Procedure
68552>>>>>>>>>    
68552>>>>>>>>>    Function ValidateDocument Returns Handle
68554>>>>>>>>>        Handle hParseErrorIntf hoParseError
68554>>>>>>>>>        Forward Get ValidateDocument to hParseErrorIntf
68556>>>>>>>>>        If hParseErrorIntf Begin
68558>>>>>>>>>            Get CreateXMLObject U_cXMLDOMParseError hParseErrorIntf to hoParseError
68559>>>>>>>>>        End
68559>>>>>>>>>>
68559>>>>>>>>>        Function_Return hoParseError
68560>>>>>>>>>    End_Function
68561>>>>>>>>>    
68561>>>>>>>>>    Function AddExternalSchemaDocument String sSchema Handle hoSchema Returns Boolean
68563>>>>>>>>>        Handle hInfc
68563>>>>>>>>>        Boolean bOk
68563>>>>>>>>>        Get XmlInterface of hoSchema to hInfc
68564>>>>>>>>>        Forward Get AddExternalSchemaDocument sSchema hInfc to bOk
68566>>>>>>>>>        Function_Return (not(bOk))
68567>>>>>>>>>    End_Function
68568>>>>>>>>>    
68568>>>>>>>>>    Function AddExternalSchemaFile String sSchema String sFile Returns Boolean
68570>>>>>>>>>        Boolean bOk
68570>>>>>>>>>        Forward Get AddExternalSchemaFile sSchema sFile to bOk
68572>>>>>>>>>        Function_Return (not(bOk))
68573>>>>>>>>>    End_Function
68574>>>>>>>>>    
68574>>>>>>>>>    Procedure Set psSelectionNamespaces String sNamespaces
68576>>>>>>>>>        Set psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
68577>>>>>>>>>    End_Procedure
68578>>>>>>>>>    
68578>>>>>>>>>    Function psSelectionNamespaces Returns String
68580>>>>>>>>>        String  sNamespaces
68580>>>>>>>>>        Get psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
68581>>>>>>>>>        Function_Return sNamespaces
68582>>>>>>>>>    End_Function
68583>>>>>>>>>    
68583>>>>>>>>>    Procedure Set pbMultipleErrorMessages Boolean bMultipleErrors
68585>>>>>>>>>        Set pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
68586>>>>>>>>>    End_Procedure
68587>>>>>>>>>    
68587>>>>>>>>>    Function pbMultipleErrorMessages Returns Boolean
68589>>>>>>>>>        Boolean bMultipleErrors
68589>>>>>>>>>        Get pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
68590>>>>>>>>>        Function_Return bMultipleErrors
68591>>>>>>>>>    End_Function
68592>>>>>>>>>    
68592>>>>>>>>>    Procedure ErrorCreatingXMLObject
68594>>>>>>>>>        Error DFERR_XML_INTERNAL_ERROR "Could not create XML COM object. MSXML6 may not be properly installed and registered."
68595>>>>>>>>>>
68595>>>>>>>>>    End_Procedure
68596>>>>>>>>>    
68596>>>>>>>>>    // returns the last parse error. If 0, you know everything parsed. This can be
68596>>>>>>>>>    // used along wit pbReadyState to load XML documents in async mode.
68596>>>>>>>>>    Function LastParseError Returns Integer
68598>>>>>>>>>        Integer iErr
68598>>>>>>>>>        Handle hoParseErrorReport
68598>>>>>>>>>        Get phXMLErrorObject to hoParseErrorReport
68599>>>>>>>>>        Get piErrorCode of hoParseErrorReport to iErr
68600>>>>>>>>>        Send Destroy of hoParseErrorReport
68601>>>>>>>>>        Function_Return iErr
68602>>>>>>>>>    End_Function
68603>>>>>>>>>    
68603>>>>>>>>>    
68603>>>>>>>>>End_Class
68604>>>>>>>
68604>>>>>>>//Use VDFD_Commands.pkg
68604>>>>>>>
68604>>>>>>>Class cDFD_Set is a Set
68605>>>>>>>
68605>>>>>>>    // Construct_Object: Object constructor.
68605>>>>>>>    Procedure Construct_Object
68607>>>>>>>        Forward Send Construct_Object
68609>>>>>>>
68609>>>>>>>        // Define new Properties:
68609>>>>>>>        Property Boolean pbTrimElements    True
68610>>>>>>>        Property Boolean pbNoBlanksAllowed True
68611>>>>>>>        Property Boolean pbIgnoreCase      False // not implemented yet.
68612>>>>>>>
68612>>>>>>>        //TODO: peStoreAs
68612>>>>>>>        Property Boolean peStoreAs // normal, uppercase, lowercase
68613>>>>>>>
68613>>>>>>>        // Create child objects:
68613>>>>>>>
68613>>>>>>>        // Set property values:
68613>>>>>>>
68613>>>>>>>    End_Procedure
68614>>>>>>>
68614>>>>>>>    Procedure End_Construct_Object
68616>>>>>>>        Forward Send End_Construct_Object
68618>>>>>>>        String sName
68618>>>>>>>        Get Object_Label to sName
68619>>>>>>>        If (sName = "OOBJECT") Begin
68621>>>>>>>            Set Name to "oDFD_Set"
68622>>>>>>>        End
68622>>>>>>>>
68622>>>>>>>
68622>>>>>>>        // Add your code that needs to be executed at the end of the object construction here:
68622>>>>>>>
68622>>>>>>>    End_Procedure
68623>>>>>>>
68623>>>>>>>    // Create and augment procedures and functions
68623>>>>>>>    Procedure Add_Element String sVal Returns Integer
68625>>>>>>>        If (pbTrimElements(Self)) Begin
68627>>>>>>>            Move (Trim(sVal)) to sVal
68628>>>>>>>        End
68628>>>>>>>>
68628>>>>>>>        If (pbNoBlanksAllowed(Self)) Begin
68630>>>>>>>            If (sVal="") Begin
68632>>>>>>>                Procedure_Return
68633>>>>>>>            End
68633>>>>>>>>
68633>>>>>>>        End
68633>>>>>>>>
68633>>>>>>>
68633>>>>>>>        If (pbIgnoreCase(Self)) Begin
68635>>>>>>>            //TODO: Add ignore case
68635>>>>>>>        End
68635>>>>>>>>
68635>>>>>>>
68635>>>>>>>        Forward Send Add_Element sVal
68637>>>>>>>    End_Procedure
68638>>>>>>>
68638>>>>>>>    Procedure Add_Elements String Str1 String Str2 String Str3 String Str4 String Str5 ;                           String Str6 String Str7 String Str8 String Str9 String Str10 ;                           Returns Integer
68640>>>>>>>
68640>>>>>>>        If (num_arguments >=  1) Begin
68642>>>>>>>            Send Add_Element Str1
68643>>>>>>>        End
68643>>>>>>>>
68643>>>>>>>        If (num_arguments >=  2) Begin
68645>>>>>>>            Send Add_Element Str2
68646>>>>>>>        End
68646>>>>>>>>
68646>>>>>>>        If (num_arguments >=  3) Begin
68648>>>>>>>            Send Add_Element Str3
68649>>>>>>>        End
68649>>>>>>>>
68649>>>>>>>        If (num_arguments >=  4) Begin
68651>>>>>>>            Send Add_Element Str4
68652>>>>>>>        End
68652>>>>>>>>
68652>>>>>>>        If (num_arguments >=  5) Begin
68654>>>>>>>            Send Add_Element Str5
68655>>>>>>>        End
68655>>>>>>>>
68655>>>>>>>        If (num_arguments >=  6) Begin
68657>>>>>>>            Send Add_Element Str6
68658>>>>>>>        End
68658>>>>>>>>
68658>>>>>>>        If (num_arguments >=  7) Begin
68660>>>>>>>            Send Add_Element Str7
68661>>>>>>>        End
68661>>>>>>>>
68661>>>>>>>        If (num_arguments >=  8) Begin
68663>>>>>>>            Send Add_Element Str8
68664>>>>>>>        End
68664>>>>>>>>
68664>>>>>>>        If (num_arguments >=  9) Begin
68666>>>>>>>            Send Add_Element Str9
68667>>>>>>>        End
68667>>>>>>>>
68667>>>>>>>        If (num_arguments >= 10) Begin
68669>>>>>>>            Send Add_Element Str10
68670>>>>>>>        End
68670>>>>>>>>
68670>>>>>>>    End_Procedure
68671>>>>>>>
68671>>>>>>>    Procedure OnEachItem Integer iItem String sValue
68673>>>>>>>    End_Procedure
68674>>>>>>>
68674>>>>>>>    // Create and augment procedure and functions
68674>>>>>>>    Procedure DoForEachItem Handle hMessage Handle hObject
68676>>>>>>>        Integer iLoop iCount
68676>>>>>>>        String sValue
68676>>>>>>>        Get Item_Count to iCount
68677>>>>>>>        For iLoop from 0 to (iCount-1)
68683>>>>>>>>
68683>>>>>>>            Get Value iLoop to sValue
68684>>>>>>>            If hMessage Begin
68686>>>>>>>                Send hMessage of hObject iLoop sValue
68687>>>>>>>            End
68687>>>>>>>>
68687>>>>>>>            Send OnEachItem iLoop sValue
68688>>>>>>>        Loop
68689>>>>>>>>
68689>>>>>>>    End_Procedure
68690>>>>>>>
68690>>>>>>>    Procedure CopyContents Handle hDestination
68692>>>>>>>        Integer iLoop iCount
68692>>>>>>>        Send delete_data of hDestination
68693>>>>>>>        Get Item_Count to iCount
68694>>>>>>>        For iLoop from 0 to (iCount-1)
68700>>>>>>>>
68700>>>>>>>            Send add_element of hDestination (value(Self, iLoop))
68701>>>>>>>        Loop
68702>>>>>>>>
68702>>>>>>>    End_Procedure
68703>>>>>>>
68703>>>>>>>    Procedure DisplayItem Integer iItem String sVal
68705>>>>>>>        Showln "Item: " iItem " = [" sVal "]"
68711>>>>>>>    End_Procedure
68712>>>>>>>
68712>>>>>>>    Procedure DisplayContents
68714>>>>>>>        Send DoForEachItem MSG_DisplayItem Self
68715>>>>>>>    End_Procedure
68716>>>>>>>
68716>>>>>>>    Function SetAsIntegerArray Returns Integer[]
68718>>>>>>>        Integer[] IntArray
68719>>>>>>>        Integer iLoop iCount
68719>>>>>>>        String sRetVal sValue
68719>>>>>>>        Get Item_Count to iCount
68720>>>>>>>        For iLoop from 0 to (iCount-1)
68726>>>>>>>>
68726>>>>>>>            Get Value iLoop to sValue
68727>>>>>>>            Move sValue to IntArray[iLoop]
68728>>>>>>>        Loop
68729>>>>>>>>
68729>>>>>>>        Function_Return IntArray
68730>>>>>>>    End_Procedure
68731>>>>>>>
68731>>>>>>>    Function SetAsString String sDelimiter Returns String
68733>>>>>>>        Integer iLoop iCount
68733>>>>>>>        String sRetVal sValue
68733>>>>>>>        Get Item_Count to iCount
68734>>>>>>>        For iLoop from 0 to (iCount-1)
68740>>>>>>>>
68740>>>>>>>            Get Value iLoop to sValue
68741>>>>>>>            Append sRetVal sValue
68742>>>>>>>            If (iLoop <> (iCount-1)) Begin
68744>>>>>>>                Append sRetVal sDelimiter
68745>>>>>>>            End
68745>>>>>>>>
68745>>>>>>>        Loop
68746>>>>>>>>
68746>>>>>>>        Function_Return sRetVal
68747>>>>>>>    End_Procedure
68748>>>>>>>
68748>>>>>>>    Function SetAsStringWithMax String sDelimiter Integer iMax Returns String
68750>>>>>>>        Integer iLoop iCount
68750>>>>>>>        String sRetVal sValue
68750>>>>>>>        Get Item_Count to iCount
68751>>>>>>>        For iLoop from 0 to ((iCount-1) min (iMax-1))
68757>>>>>>>>
68757>>>>>>>            Get Value iLoop to sValue
68758>>>>>>>            Append sRetVal sValue
68759>>>>>>>            If (iLoop <> (iCount-1)) Begin
68761>>>>>>>                Append sRetVal sDelimiter
68762>>>>>>>            End
68762>>>>>>>>
68762>>>>>>>        Loop
68763>>>>>>>>
68763>>>>>>>        Function_Return sRetVal
68764>>>>>>>    End_Procedure
68765>>>>>>>
68765>>>>>>>    Function SetAsQuotedStrings String sDelimiter Returns String
68767>>>>>>>        Integer iLoop iCount
68767>>>>>>>        String sRetVal sValue
68767>>>>>>>        Get Item_Count to iCount
68768>>>>>>>        For iLoop from 0 to (iCount-1)
68774>>>>>>>>
68774>>>>>>>            Get Value iLoop to sValue
68775>>>>>>>            Append sRetVal "'" sValue "'"
68778>>>>>>>            If (iLoop <> (iCount-1)) Begin
68780>>>>>>>                Append sRetVal sDelimiter
68781>>>>>>>            End
68781>>>>>>>>
68781>>>>>>>        Loop
68782>>>>>>>>
68782>>>>>>>        Function_Return sRetVal
68783>>>>>>>    End_Procedure
68784>>>>>>>
68784>>>>>>>    Function SetAsStringOfIntegers String sDelimiter Returns String
68786>>>>>>>        Integer iLoop iCount iValue
68786>>>>>>>        String sRetVal
68786>>>>>>>
68786>>>>>>>        Get Item_Count to iCount
68787>>>>>>>        For iLoop from 0 to (iCount-1)
68793>>>>>>>>
68793>>>>>>>            Get Value iLoop to iValue
68794>>>>>>>            Append sRetVal iValue
68795>>>>>>>            If (iLoop <> (iCount-1)) Begin
68797>>>>>>>                Append sRetVal sDelimiter
68798>>>>>>>            End
68798>>>>>>>>
68798>>>>>>>        Loop
68799>>>>>>>>
68799>>>>>>>        Function_Return sRetVal
68800>>>>>>>    End_Procedure
68801>>>>>>>
68801>>>>>>>    Procedure Set SetFromString String sDelimiter String sValue
68803>>>>>>>    //TODO: Add code to populate a set from delimited string values
68803>>>>>>>    End_Procedure
68804>>>>>>>
68804>>>>>>>    Procedure AddItemToXML Handle hRoot String sValue
68806>>>>>>>        Handle hItem
68806>>>>>>>        Get AddElement of hRoot "Value" sValue to hItem
68807>>>>>>>    End_Procedure
68808>>>>>>>
68808>>>>>>>    Procedure SaveToXML String sFile
68810>>>>>>>        Handle hXML hRoot
68810>>>>>>>        Boolean bOk
68810>>>>>>>        Integer iLoop iCount iVoid
68810>>>>>>>        String sRetVal sValue
68810>>>>>>>
68810>>>>>>>        Get Create (RefClass(cXMLDOMDocument))  to hXML
68811>>>>>>>        Get CreateDocumentElement of hXML "Root" to hRoot
68812>>>>>>>        Get Item_Count to iCount
68813>>>>>>>
68813>>>>>>>        // Build XML in memory
68813>>>>>>>        For iLoop from 0 to (iCount-1)
68819>>>>>>>>
68819>>>>>>>          Get Value iLoop to sValue
68820>>>>>>>          Send AddItemToXML hRoot sValue
68821>>>>>>>        Loop
68822>>>>>>>>
68822>>>>>>>
68822>>>>>>>        // Save to disk
68822>>>>>>>        Set psDocumentName of hXML to sFile
68823>>>>>>>        Get SaveXMLDocument of hXML to iVoid
68824>>>>>>>        Send Destroy of hRoot
68825>>>>>>>        Send Destroy of hXML
68826>>>>>>>
68826>>>>>>>        Function_Return sRetVal
68827>>>>>>>    End_Procedure
68828>>>>>>>
68828>>>>>>>    //TODO: LoadFromXML
68828>>>>>>>    Procedure LoadFromXML
68830>>>>>>>    End_Procedure
68831>>>>>>>
68831>>>>>>>End_Class
68832>>>>>>>
68832>>>>>>>// End of File: cDFD_Set.pkg
68832>>>>>
68832>>>>>Class cDFD_Broadcaster is a cDFD_Set 0 0 Broadcast_Handler
68833>>>>>
68833>>>>>    Procedure Construct_Object
68835>>>>>        Forward Send Construct_Object
68837>>>>>
68837>>>>>    End_Procedure
68838>>>>>
68838>>>>>    Procedure End_Construct_Object
68840>>>>>        Forward Send End_Construct_Object
68842>>>>>
68842>>>>>    End_Procedure
68843>>>>>
68843>>>>>End_Class
68844>>>>>
68844>>>>>// End of File: cDFD_Broadcaster.pkg
68844>>>
68844>>>//Use base\cDFD_Array.pkg
68844>>>//Use base\cDFD_Application.pkg
68844>>>//Use base\cDFD_ClientArea.pkg
68844>>>//Use base\cDFD_ModalPanel.pkg
68844>>>//Use base\cDFD_View.pkg
68844>>>
68844>>>// ToDo: Use base\cDFD_Button.pkg
68844>>>//Use base\cDFD_ImageList32.pkg
68844>>>//Use base\cDFD_DbForm.pkg
68844>>>//Use base\cDFD_DbModalPanel.pkg
68844>>>//Use base\cDFD_DbRadioGroup.pkg
68844>>>//Use base\cDFD_Form.pkg
68844>>>//Use base\cDFD_Group.pkg
68844>>>//Use base\cDFD_Radio.pkg
68844>>>//Use base\cDFD_RadioGroup.pkg
68844>>>//Use base\cDFD_Panel.pkg
68844>>>//Use base\cDFD_Timer.pkg
68844>>>//Use base\cDFD_Set.pkg
68844>>>//Use base\cDFD_Checkbox.pkg
68844>>>//Use base\cDFD_BusinessProcess.pkg
68844>>>//Use base\cDFD_DbCheckbox.pkg
68844>>>//Use base\cDFD_DbTabDialog.pkg
68844>>>//Use base\cDFD_DbView.pkg
68844>>>//Use base\cDFD_DfTimer.pkg
68844>>>//Use base\cDFD_TreeView.pkg
68844>>>//Use base\cDFD_TextEdit.pkg
68844>>>//Use base\cDFD_DfTimer.pkg
68844>>>//Use base\cDFD_DbTextEdit.pkg
68844>>>
68844>>>
68844>>>// Obsolete Classes //
68844>>>//Use base\cDFD_Grid.pkg
68844>>>//Use base\cDFD_List.pkg
68844>>>//Use base\cDFD_DbGrid.pkg
68844>>>//Use base\cDFD_DbList.pkg
68844>
68844>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
68844>>>// these are all the packages used in a standard MDI menubar/toolbar system
68844>>>
68844>>>Use cCJCommandBarSystem.pkg
68844>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
68844>>>>>Use Dfpanel.pkg
68844>>>>>Use cCJCommandBarSystem.pkg
68844>>>>>Use LanguageText.pkg
68844>>>>>
68844>>>>>
68844>>>>>Class cCJUndoMenuItem is a cCJMenuItem
68845>>>>>    
68845>>>>>    Procedure Construct_Object
68847>>>>>        Forward Send Construct_Object
68849>>>>>        Set psCaption   to C_$CaptionUndo
68850>>>>>        Set psToolTip to C_$ToolTipUndo
68851>>>>>        Set psDescription to C_$DescUndo
68852>>>>>        Set psImage to "ActionUndo.ico"
68853>>>>>        Set pbActiveUpdate to True
68854>>>>>        Set psCategory to C_$CategoryEdit
68855>>>>>        Set psShortcut to C_$Key_Ctrl_Z
68856>>>>>    End_Procedure
68857>>>>>    
68857>>>>>    Procedure OnExecute Variant vCommandBarControl
68859>>>>>        Send Undo of (focus(Self))
68860>>>>>    End_Procedure
68861>>>>>    
68861>>>>>    Function IsEnabled Returns Boolean
68863>>>>>        Boolean bEnabled
68863>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
68864>>>>>        Function_Return bEnabled
68865>>>>>    End_Function
68866>>>>>    
68866>>>>>End_Class
68867>>>>>
68867>>>>>
68867>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
68868>>>>>    
68868>>>>>    Procedure Construct_Object
68870>>>>>        Forward Send Construct_Object
68872>>>>>        Set psCaption   to C_$CaptionDelete
68873>>>>>        Set psToolTip to C_$ToolTipDelete
68874>>>>>        Set psDescription to C_$DescDelete
68875>>>>>        Set psImage to "actionDelete.ico"
68876>>>>>        Set psShortcut to C_$Key_Delete
68877>>>>>        Set pbActiveUpdate to True
68878>>>>>        Set psCategory to C_$CategoryEdit
68879>>>>>    End_Procedure
68880>>>>>    
68880>>>>>    
68880>>>>>    Procedure OnExecute Variant vCommandBarControl
68882>>>>>        Send Delete of (focus(Self))
68883>>>>>    End_Procedure
68884>>>>>    
68884>>>>>    Function IsEnabled Returns Boolean
68886>>>>>        Boolean bEnabled
68886>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
68887>>>>>        Function_Return bEnabled
68888>>>>>    End_Function
68889>>>>>    
68889>>>>>End_Class
68890>>>>>
68890>>>>>
68890>>>>>Class cCJCutMenuItem is a cCJMenuItem
68891>>>>>    
68891>>>>>    Procedure Construct_Object
68893>>>>>        Forward Send Construct_Object
68895>>>>>        Set psCaption   to C_$CaptionCut
68896>>>>>        Set psToolTip to C_$TooltipCut
68897>>>>>        Set psDescription to C_$DescCut
68898>>>>>        Set psImage to "actionCut.ico"
68899>>>>>        Set psShortcut to C_$Key_Ctrl_X
68900>>>>>        Set pbActiveUpdate to True
68901>>>>>        Set psCategory to C_$CategoryEdit
68902>>>>>    End_Procedure
68903>>>>>    
68903>>>>>    
68903>>>>>    Procedure OnExecute Variant vCommandBarControl
68905>>>>>        Send Cut of (focus(Self))
68906>>>>>    End_Procedure
68907>>>>>    
68907>>>>>    Function IsEnabled Returns Boolean
68909>>>>>        Boolean bEnabled
68909>>>>>        Get CanCut of (Focus(Self)) to bEnabled
68910>>>>>        Function_Return bEnabled
68911>>>>>    End_Function
68912>>>>>    
68912>>>>>End_Class
68913>>>>>
68913>>>>>
68913>>>>>Class cCJCopyMenuItem is a cCJMenuItem
68914>>>>>    
68914>>>>>    Procedure Construct_Object
68916>>>>>        Forward Send Construct_Object
68918>>>>>        Set psCaption   to C_$CaptionCopy
68919>>>>>        Set psToolTip to C_$ToolTipCopy
68920>>>>>        Set psDescription to C_$DescCopy
68921>>>>>        Set psImage to "actionCopy.ico"
68922>>>>>        Set psShortcut to C_$Key_Ctrl_C
68923>>>>>        Set pbActiveUpdate to True
68924>>>>>        Set psCategory to C_$CategoryEdit
68925>>>>>    End_Procedure
68926>>>>>    
68926>>>>>    
68926>>>>>    Procedure OnExecute Variant vCommandBarControl
68928>>>>>        Send Copy of (focus(Self))
68929>>>>>    End_Procedure
68930>>>>>    
68930>>>>>    Function IsEnabled Returns Boolean
68932>>>>>        Boolean bEnabled
68932>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
68933>>>>>        Function_Return bEnabled
68934>>>>>    End_Function
68935>>>>>    
68935>>>>>End_Class
68936>>>>>
68936>>>>>
68936>>>>>Class cCJPasteMenuItem is a cCJMenuItem
68937>>>>>    
68937>>>>>    Procedure Construct_Object
68939>>>>>        Forward Send Construct_Object
68941>>>>>        Set psCaption   to C_$CaptionPaste
68942>>>>>        Set psToolTip to C_$ToolTipPaste
68943>>>>>        Set psDescription to C_$DescPaste
68944>>>>>        Set psImage to "actionPaste.ico"
68945>>>>>        Set pbActiveUpdate to True
68946>>>>>        Set psShortcut to C_$Key_Ctrl_V
68947>>>>>        Set psCategory to C_$CategoryEdit
68948>>>>>    End_Procedure
68949>>>>>    
68949>>>>>    
68949>>>>>    Procedure OnExecute Variant vCommandBarControl
68951>>>>>        Send Paste of (focus(Self))
68952>>>>>    End_Procedure
68953>>>>>    
68953>>>>>    Function IsEnabled Returns Boolean
68955>>>>>        Boolean bEnabled
68955>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
68956>>>>>        Function_Return bEnabled
68957>>>>>    End_Function
68958>>>>>    
68958>>>>>End_Class
68959>>>>>
68959>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
68960>>>>>    
68960>>>>>    Procedure Construct_Object
68962>>>>>        Forward Send Construct_Object
68964>>>>>        Set psCaption   to C_$CaptionSelectAll
68965>>>>>        Set psToolTip to C_$ToolTipSelectAll
68966>>>>>        Set psDescription to C_$DescSelectAll
68967>>>>>        Set pbActiveUpdate to True
68968>>>>>        Set psShortcut to C_$Key_Ctrl_A
68969>>>>>        Set psCategory to C_$CategoryEdit
68970>>>>>    End_Procedure
68971>>>>>    
68971>>>>>    
68971>>>>>    Procedure OnExecute Variant vCommandBarControl
68973>>>>>        Send Select_All of (focus(Self))
68974>>>>>    End_Procedure
68975>>>>>    
68975>>>>>    Function IsEnabled Returns Boolean
68977>>>>>        Boolean bEnabled
68977>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
68978>>>>>        Function_Return bEnabled
68979>>>>>    End_Function
68980>>>>>    
68980>>>>>End_Class
68981>>>>>
68981>>>>>
68981>>>>>Class cCJExitMenuItem is a cCJMenuItem
68982>>>>>    
68982>>>>>    Procedure Construct_Object
68984>>>>>        Forward Send Construct_Object
68986>>>>>        Set psCaption to C_$CaptionExit
68987>>>>>        Set psToolTip to C_$ToolTipExit
68988>>>>>        Set psDescription to C_$ToolTipExit
68989>>>>>        Set psShortcut to C_$Key_Alt_F4
68990>>>>>        Set psCategory to C_$CategoryFile
68991>>>>>    End_Procedure
68992>>>>>    
68992>>>>>    Procedure OnExecute Variant vCommandBarControl
68994>>>>>        Send Exit_Application of Desktop
68995>>>>>    End_Procedure
68996>>>>>    
68996>>>>>End_Class
68997>>>>>
68997>>>>>Class cCJHelpMenuItem is a cCJMenuItem
68998>>>>>    
68998>>>>>    Procedure Construct_Object
69000>>>>>        Forward Send Construct_Object
69002>>>>>        Set psCaption to C_$CaptionHelp
69003>>>>>        Set psDescription to C_$ToolTipHelp
69004>>>>>        Set psToolTip to C_$DescHelp
69005>>>>>        Set psImage to "ActionHelp.ico"
69006>>>>>        Set psShortcut to "F1"
69007>>>>>        Set psCategory to C_$CategoryHelp
69008>>>>>    End_Procedure
69009>>>>>    
69009>>>>>    Procedure OnExecute Variant vCommandBarControl
69011>>>>>        Send Help of (Focus(Self))
69012>>>>>    End_Procedure
69013>>>>>    
69013>>>>>End_Class
69014>>>>>
69014>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
69015>>>>>    
69015>>>>>    Procedure Construct_Object
69017>>>>>        Forward Send Construct_Object
69019>>>>>        Set psCaption to C_$CaptionAddStatusbar
69020>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
69021>>>>>        Set psDescription to  C_$DescAddStatusbar
69022>>>>>        Set psCategory to C_$CategoryWindow
69023>>>>>    End_Procedure
69024>>>>>    
69024>>>>>    Procedure OnExecute Variant vCommandBarControl
69026>>>>>        Handle hoCommandBars hoClientArea
69026>>>>>        Get CommandBarSystemObject to hoCommandBars
69027>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69028>>>>>        If hoClientArea Begin
69030>>>>>            // the clientarea's parent panel has message
69030>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
69031>>>>>        End
69031>>>>>>
69031>>>>>    End_Procedure
69032>>>>>    
69032>>>>>    Function IsChecked Returns Boolean
69034>>>>>        Boolean bOn
69034>>>>>        Handle hoCommandBars hoClientArea
69034>>>>>        Get CommandBarSystemObject to hoCommandBars
69035>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69036>>>>>        If hoClientArea Begin
69038>>>>>            // the clientarea's parent panel has message
69038>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
69039>>>>>        End
69039>>>>>>
69039>>>>>        Function_Return bOn
69040>>>>>    End_Function
69041>>>>>End_Class
69042>>>>>
69042>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
69043>>>>>    
69043>>>>>    Procedure Construct_Object
69045>>>>>        Forward Send Construct_Object
69047>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
69048>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
69049>>>>>        Set psDescription to C_$DescAutoArrangeIcons
69050>>>>>        Set psCategory to C_$CategoryWindow
69051>>>>>    End_Procedure
69052>>>>>    
69052>>>>>    Procedure OnExecute Variant vCommandBarControl
69054>>>>>        Handle hoCommandBars hoClientArea
69054>>>>>        Get CommandBarSystemObject to hoCommandBars
69055>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69056>>>>>        If hoClientArea Begin
69058>>>>>            // the clientarea's parent panel has message
69058>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
69059>>>>>        End
69059>>>>>>
69059>>>>>    End_Procedure
69060>>>>>    
69060>>>>>    Function IsChecked Returns Boolean
69062>>>>>        Boolean bOn
69062>>>>>        Handle hoCommandBars hoClientArea
69062>>>>>        Get CommandBarSystemObject to hoCommandBars
69063>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69064>>>>>        If hoClientArea Begin
69066>>>>>            // the clientarea's parent panel has message
69066>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
69067>>>>>        End
69067>>>>>>
69067>>>>>        Function_Return bOn
69068>>>>>    End_Function
69069>>>>>End_Class
69070>>>>>
69070>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
69071>>>>>    
69071>>>>>    Procedure Construct_Object
69073>>>>>        Forward Send Construct_Object
69075>>>>>        Set psCaption to C_$CaptionRestoreMenus
69076>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
69077>>>>>        Set psDescription to C_$DescRestoreMenus
69078>>>>>        Set psCategory to C_$CategoryWindow
69079>>>>>    End_Procedure
69080>>>>>    
69080>>>>>    Procedure OnExecute Variant vCommandBarControl
69082>>>>>        Handle hoCommandBars
69082>>>>>        Get CommandBarSystemObject to hoCommandBars
69083>>>>>        Send RestoreLayout of hoCommandBars
69084>>>>>    End_Procedure
69085>>>>>    
69085>>>>>End_Class
69086>>>>>
69086>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
69087>>>>>    
69087>>>>>    Procedure Construct_Object
69089>>>>>        Forward Send Construct_Object
69091>>>>>        Set psCaption to C_$CaptionCascade
69092>>>>>        Set psToolTip to C_$ToolTipCascade
69093>>>>>        Set psDescription to  C_$DescCascade
69094>>>>>        Set psImage to "ActionCascade.ico"
69095>>>>>        Set psCategory to C_$CategoryWindow
69096>>>>>    End_Procedure
69097>>>>>    
69097>>>>>    Procedure OnExecute Variant vCommandBarControl
69099>>>>>        Handle hoCommandBars hoClientArea
69099>>>>>        Get CommandBarSystemObject to hoCommandBars
69100>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69101>>>>>        If hoClientArea Begin
69103>>>>>            Send Cascade_Windows of hoClientArea
69104>>>>>        End
69104>>>>>>
69104>>>>>    End_Procedure
69105>>>>>End_Class
69106>>>>>
69106>>>>>Class cCJTileHorizontally is a cCJMenuItem
69107>>>>>    
69107>>>>>    Procedure Construct_Object
69109>>>>>        Forward Send Construct_Object
69111>>>>>        Set psCaption to C_$CaptionTileHorizontally
69112>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
69113>>>>>        Set psDescription to  C_$DescTileHorizontally
69114>>>>>        Set psImage to "ActionTileHorizontally.ico"
69115>>>>>        Set psCategory to C_$CategoryWindow
69116>>>>>    End_Procedure
69117>>>>>    
69117>>>>>    Procedure OnExecute Variant vCommandBarControl
69119>>>>>        Handle hoCommandBars hoClientArea
69119>>>>>        Get CommandBarSystemObject to hoCommandBars
69120>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69121>>>>>        If hoClientArea Begin
69123>>>>>            Send Tile_Windows_Horizontal of hoClientArea
69124>>>>>        End
69124>>>>>>
69124>>>>>    End_Procedure
69125>>>>>End_Class
69126>>>>>
69126>>>>>Class cCJTileVertically is a cCJMenuItem
69127>>>>>    
69127>>>>>    Procedure Construct_Object
69129>>>>>        Forward Send Construct_Object
69131>>>>>        Set psCaption to C_$CaptionTileVertically
69132>>>>>        Set psToolTip to C_$ToolTipTileVertically
69133>>>>>        Set psDescription to  C_$DescTileVertically
69134>>>>>        Set psImage to "ActionTileVertically.ico"
69135>>>>>        Set psCategory to C_$CategoryWindow
69136>>>>>    End_Procedure
69137>>>>>    
69137>>>>>    Procedure OnExecute Variant vCommandBarControl
69139>>>>>        Handle hoCommandBars hoClientArea
69139>>>>>        Get CommandBarSystemObject to hoCommandBars
69140>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69141>>>>>        If hoClientArea Begin
69143>>>>>            Send Tile_Windows_Vertical of hoClientArea
69144>>>>>        End
69144>>>>>>
69144>>>>>    End_Procedure
69145>>>>>End_Class
69146>>>>>
69146>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
69147>>>>>    
69147>>>>>    Procedure Construct_Object
69149>>>>>        Forward Send Construct_Object
69151>>>>>        Set psCaption to C_$CaptionMinimizeWindows
69152>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
69153>>>>>        Set psDescription to  C_$DescMinimizeWindows
69154>>>>>        Set psCategory to C_$CategoryWindow
69155>>>>>    End_Procedure
69156>>>>>    
69156>>>>>    Procedure OnExecute Variant vCommandBarControl
69158>>>>>        Handle hoCommandBars hoClientArea
69158>>>>>        Get CommandBarSystemObject to hoCommandBars
69159>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69160>>>>>        If hoClientArea Begin
69162>>>>>            // the clientarea's parent panel has message
69162>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
69163>>>>>        End
69163>>>>>>
69163>>>>>    End_Procedure
69164>>>>>End_Class
69165>>>>>
69165>>>>>
69165>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
69166>>>>>    
69166>>>>>    Procedure Construct_Object
69168>>>>>        Forward Send Construct_Object
69170>>>>>        Set psCaption to C_$CaptionRestoreWindows
69171>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
69172>>>>>        Set psDescription to  C_$DescRestoreWindows
69173>>>>>        Set psCategory to C_$CategoryWindow
69174>>>>>    End_Procedure
69175>>>>>    
69175>>>>>    Procedure OnExecute Variant vCommandBarControl
69177>>>>>        Handle hoCommandBars hoClientArea
69177>>>>>        Get CommandBarSystemObject to hoCommandBars
69178>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69179>>>>>        If hoClientArea Begin
69181>>>>>            // the clientarea's parent panel has message
69181>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
69182>>>>>        End
69182>>>>>>
69182>>>>>    End_Procedure
69183>>>>>End_Class
69184>>>>>
69184>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
69185>>>>>    
69185>>>>>    Procedure Construct_Object
69187>>>>>        Forward Send Construct_Object
69189>>>>>        Set psCaption to C_$CaptionArrangeIcons
69190>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
69191>>>>>        Set psDescription to  C_$DescArrangeIcons
69192>>>>>        Set psCategory to C_$CategoryWindow
69193>>>>>    End_Procedure
69194>>>>>    
69194>>>>>    Procedure OnExecute Variant vCommandBarControl
69196>>>>>        Handle hoCommandBars hoClientArea
69196>>>>>        Get CommandBarSystemObject to hoCommandBars
69197>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69198>>>>>        If hoClientArea Begin
69200>>>>>            Send Arrange_Icons of hoClientArea
69201>>>>>        End
69201>>>>>>
69201>>>>>    End_Procedure
69202>>>>>    
69202>>>>>End_Class
69203>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
69203>>>>>Use cCJCommandBarSystem.pkg
69203>>>>>Use LanguageText.pkg
69203>>>>>
69203>>>>>// It is expected that if you use this class that you provide an about object that is
69203>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
69203>>>>>// because you may wish to create your own custom about package.
69203>>>>>
69203>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
69204>>>>>
69204>>>>>    Procedure Construct_Object
69206>>>>>        Forward Send Construct_Object
69208>>>>>        Set psCaption to C_$CaptionAbout
69209>>>>>        Set psDescription to C_$ToolTipAbout
69210>>>>>        Set psToolTip to C_$DescAbout
69211>>>>>        Set psImage to "ActionAbout.ico"
69212>>>>>        Set psCategory to C_$CategoryHelp
69213>>>>>    End_Procedure
69214>>>>>    
69214>>>>>    Procedure OnExecute Variant vCommandBarControl
69216>>>>>        Handle hoCommandBars hoClientArea
69216>>>>>        Get CommandBarSystemObject to hoCommandBars
69217>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
69218>>>>>        If hoClientArea Begin
69220>>>>>            Send Activate_About of hoClientArea
69221>>>>>        End
69221>>>>>>
69221>>>>>    End_Procedure
69222>>>>>
69222>>>>>End_Class
69223>>>>>
69223>>>>>
69223>>>Use cCJDeoMenuItemClasses.pkg
69223>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
69223>>>>>Use cCJCommandBarSystem.pkg
69223>>>>>
69223>>>>>Register_Function Client_ID Returns Integer
69223>>>>>
69223>>>>>// only used by cCJMDIWIndowsMenuItem
69223>>>>>Class cCJMDIWindowItem is a cCJMenuItem
69224>>>>>    
69224>>>>>    Procedure Construct_Object
69226>>>>>        Forward Send Construct_Object
69228>>>>>        Property Handle phWindow 0 // object id of view
69229>>>>>        Set pbControlFlagNoMovable to True
69230>>>>>        Set pbActiveUpdate to True
69231>>>>>    End_Procedure
69232>>>>>    
69232>>>>>    Procedure OnExecute Variant vCommandBarControl
69234>>>>>        Handle hWindow
69234>>>>>        Get phWindow to hWindow
69235>>>>>        Send Activate_View of hWindow
69236>>>>>    End_Procedure
69237>>>>>    
69237>>>>>End_Class
69238>>>>>
69238>>>>>
69238>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
69239>>>>>    
69239>>>>>    Procedure Construct_Object
69241>>>>>        Forward Send Construct_Object
69243>>>>>        Property Handle[] phArrayOfWindows
69244>>>>>        Set peControlType to xtpControlPopup
69245>>>>>        Set psCategory to C_$CategoryWindow
69246>>>>>    End_Procedure
69247>>>>>    
69247>>>>>    // This adds MDI windows to the existing menu items.
69247>>>>>    // This removes any existing windows menus and always adds a new set to the end
69247>>>>>    
69247>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
69249>>>>>        Handle  hClientArea hView
69249>>>>>        String  sLabel
69249>>>>>        Integer i iWindows
69249>>>>>        Handle[] hArrayOfWindows
69250>>>>>        Variant vItem
69250>>>>>        
69250>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
69250>>>>>        // also assume that destroying an action removes all menu instances of that action
69250>>>>>        Get phArrayOfWindows to hArrayOfWindows
69251>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
69252>>>>>        For i from 0 to (iWindows-1)
69258>>>>>>
69258>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
69259>>>>>        Loop
69260>>>>>>
69260>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
69261>>>>>        
69261>>>>>        // Add all views to this menu. Create the action and add the item
69261>>>>>        Move 0 to i
69262>>>>>        Get Client_Id to hClientArea // object id of client area
69263>>>>>        If (hClientArea > 0) Begin
69265>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
69266>>>>>            While (hView <> 0)
69270>>>>>                If (Active_State(hView)) Begin
69272>>>>>                    // create the action
69272>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
69273>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
69274>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
69275>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
69276>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
69278>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
69279>>>>>                    End
69279>>>>>>
69279>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
69280>>>>>                    If (i=0) Begin
69282>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
69283>>>>>                    End
69283>>>>>>
69283>>>>>                    // Create a menu item for this action
69283>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
69284>>>>>                    Increment i
69285>>>>>                End
69285>>>>>>
69285>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
69286>>>>>            Loop
69287>>>>>>
69287>>>>>        End
69287>>>>>>
69287>>>>>        
69287>>>>>        Set phArrayOfWindows to hArrayOfWindows
69288>>>>>        
69288>>>>>    End_Procedure
69289>>>>>    
69289>>>>>End_Class
69290>
69290>Object oHtmlHelp is a cHtmlHelp
69292>End_Object
69293>
69293>Object oApplication is a cApplication
69295>    Set peHelpType to htHtmlHelp
69296>
69296>    Object oConnection is a cConnection
69298>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\LoginEncryption.pkg)
69298>>>Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cLoginEncryption.pkg)
69298>>>>>Use cCryptographer.pkg
Including file: cCryptographer.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
69298>>>>>>>Use VdfBase.pkg
69298>>>>>>>
69298>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
69298>>>>>>>>>//   Author  : Ulbe Stellema
69298>>>>>>>>>// Algorithm classes
69298>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
69298>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
69298>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
69298>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
69298>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
69298>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
69298>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
69298>>>>>>>>>
69298>>>>>>>>>// Algorithm types
69298>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
69298>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
69298>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
69298>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
69298>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
69298>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
69298>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
69298>>>>>>>>>
69298>>>>>>>>>// Generic sub-ids
69298>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
69298>>>>>>>>>
69298>>>>>>>>>// RSA sub-ids
69298>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
69298>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
69298>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
69298>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
69298>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
69298>>>>>>>>>
69298>>>>>>>>>// DSS sub-ids
69298>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
69298>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
69298>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
69298>>>>>>>>>
69298>>>>>>>>>// DES sub_ids
69298>>>>>>>>>Define ALG_SID_DES                      for 1
69298>>>>>>>>>Define ALG_SID_3DES                     for 3
69298>>>>>>>>>Define ALG_SID_DESX                     for 4
69298>>>>>>>>>Define ALG_SID_IDEA                     for 5
69298>>>>>>>>>Define ALG_SID_CAST                     for 6
69298>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
69298>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
69298>>>>>>>>>Define ALG_SID_3DES_112                 for 9
69298>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
69298>>>>>>>>>Define ALG_SID_RC5                      for 13
69298>>>>>>>>>Define ALG_SID_AES_128                  for 14
69298>>>>>>>>>Define ALG_SID_AES_192                  for 15
69298>>>>>>>>>Define ALG_SID_AES_256                  for 16
69298>>>>>>>>>Define ALG_SID_AES                      for 17
69298>>>>>>>>>
69298>>>>>>>>>// Fortezza sub-ids
69298>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
69298>>>>>>>>>Define ALG_SID_TEK                      for 11
69298>>>>>>>>>
69298>>>>>>>>>// RC2 sub-ids
69298>>>>>>>>>Define ALG_SID_RC2                      for 2
69298>>>>>>>>>
69298>>>>>>>>>// Stream cipher sub-ids
69298>>>>>>>>>Define ALG_SID_RC4                      for 1
69298>>>>>>>>>Define ALG_SID_SEAL                     for 2
69298>>>>>>>>>
69298>>>>>>>>>// Diffie-Hellman sub-ids
69298>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
69298>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
69298>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
69298>>>>>>>>>Define ALG_SID_KEA                      for 4
69298>>>>>>>>>
69298>>>>>>>>>// Hash sub ids
69298>>>>>>>>>Define ALG_SID_MD2                      for 1
69298>>>>>>>>>Define ALG_SID_MD4                      for 2
69298>>>>>>>>>Define ALG_SID_MD5                      for 3
69298>>>>>>>>>Define ALG_SID_SHA                      for 4
69298>>>>>>>>>Define ALG_SID_SHA1                     for 4
69298>>>>>>>>>Define ALG_SID_MAC                      for 5
69298>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
69298>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
69298>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
69298>>>>>>>>>Define ALG_SID_HMAC                     for 9
69298>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
69298>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
69298>>>>>>>>>Define ALG_SID_SHA_256                  for 12
69298>>>>>>>>>Define ALG_SID_SHA_384                  for 13
69298>>>>>>>>>Define ALG_SID_SHA_512                  for 14
69298>>>>>>>>>
69298>>>>>>>>>// secure channel sub ids
69298>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
69298>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
69298>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
69298>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
69298>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
69298>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
69298>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
69298>>>>>>>>>
69298>>>>>>>>>// algorithm identifier definitions
69298>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
69298>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
69298>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
69298>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
69298>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
69298>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
69298>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
69298>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
69298>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
69298>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
69298>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
69298>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
69298>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
69298>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
69298>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
69298>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
69298>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
69298>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
69298>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
69298>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
69298>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
69298>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
69298>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
69298>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
69298>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
69298>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
69298>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
69298>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
69298>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
69298>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
69298>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
69298>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
69298>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
69298>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
69298>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
69298>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
69298>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
69298>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
69298>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
69298>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
69298>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
69298>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
69298>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
69298>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
69298>>>>>>>>>
69298>>>>>>>>>// Providers
69298>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
69298>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
69298>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
69298>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
69298>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
69298>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
69298>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
69298>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
69298>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
69298>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
69298>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
69298>>>>>>>>>
69298>>>>>>>>>// dwFlags definitions for CryptAcquireContext
69298>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
69298>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
69298>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
69298>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
69298>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
69298>>>>>>>>>
69298>>>>>>>>>// dwFlag definitions for CryptGenKey
69298>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
69298>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
69298>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
69298>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
69298>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
69298>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
69298>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
69298>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
69298>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
69298>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
69298>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
69298>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
69298>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
69298>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
69298>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
69298>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
69298>>>>>>>>>
69298>>>>>>>>>// Provider types
69298>>>>>>>>>Define PROV_RSA_FULL                    for 1
69298>>>>>>>>>Define PROV_RSA_SIG                     for 2
69298>>>>>>>>>Define PROV_DSS                         for 3
69298>>>>>>>>>Define PROV_FORTEZZA                    for 4
69298>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
69298>>>>>>>>>Define PROV_SSL                         for 6
69298>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
69298>>>>>>>>>Define PROV_DSS_DH                      for 13
69298>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
69298>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
69298>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
69298>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
69298>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
69298>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
69298>>>>>>>>>Define PROV_RNG                         for 21
69298>>>>>>>>>Define PROV_INTEL_SEC                   for 22
69298>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
69298>>>>>>>>>Define PROV_RSA_AES                     for 24
69298>>>>>>>>>
69298>>>>>>>>>// KP_MODE
69298>>>>>>>>>// KP_MODE
69298>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
69298>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
69298>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
69298>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
69298>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
69298>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
69298>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
69298>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
69298>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
69298>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
69298>>>>>>>>>
69298>>>>>>>>>// dwParam definitions for CryptGetKeyParam
69298>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
69298>>>>>>>>>Define KP_SALT                          for 2       // Salt value
69298>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
69298>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
69298>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
69298>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
69298>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
69298>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
69298>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
69298>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
69298>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
69298>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
69298>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
69298>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
69298>>>>>>>>>Define KP_Y                             for 15      // Y value
69298>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
69298>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
69298>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
69298>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
69298>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
69298>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
69298>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
69298>>>>>>>>>Define KP_RP                            for 23
69298>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
69298>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
69298>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
69298>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
69298>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
69298>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
69298>>>>>>>>>Define KP_KEYVAL                        for 30
69298>>>>>>>>>Define KP_ADMIN_PIN                     for 31
69298>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
69298>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
69298>>>>>>>>>Define KP_PREHASH                       for 34
69298>>>>>>>>>Define KP_ROUNDS                        for 35
69298>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
69298>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
69298>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
69298>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
69298>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
69298>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
69298>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
69298>>>>>>>>>
69298>>>>>>>>>// dwParam definitions for CryptGetHashParam
69298>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
69298>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
69298>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
69298>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
69298>>>>>>>>>
69298>>>>>>>>>// key BLOB types
69298>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
69298>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
69298>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
69298>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
69298>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
69298>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
69298>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
69298>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
69298>>>>>>>>>
69298>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
69298>>>>>>>>>
69298>>>>>>>>>//  Structure cryptimportkey
69298>>>>>>>>>Struct PUBLICKEYSTRUC
69298>>>>>>>>>    UChar    bType
69298>>>>>>>>>    UChar    bVersion
69298>>>>>>>>>    UShort   reserved
69298>>>>>>>>>    UInteger aiKeyAlg
69298>>>>>>>>>End_Struct
69298>>>>>>>>>
69298>>>>>>>>>Struct tPLAINTEXTKEYBLOB
69298>>>>>>>>>    PUBLICKEYSTRUC hdr
69298>>>>>>>>>    PUBLICKEYSTRUC hdr
69298>>>>>>>>>    UInteger       dwKeySize
69298>>>>>>>>>//    UChar[]        rgbKeyData
69298>>>>>>>>>End_Struct
69298>>>>>>>>>
69298>>>>>>>>>
69298>>>>>>>>>
69298>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
69298>>>>>>>>>Struct HMAC_INFO
69298>>>>>>>>>    UInteger HashAlgid
69298>>>>>>>>>    Pointer pbInnerString
69298>>>>>>>>>    DWord cbInnerString
69298>>>>>>>>>    Pointer pbOuterString
69298>>>>>>>>>    DWord cbOuterString
69298>>>>>>>>>End_Struct
69298>>>>>>>>>
69298>>>>>>>>>
69298>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
69299>>>>>>>>>
69299>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
69300>>>>>>>>>
69300>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
69301>>>>>>>>>
69301>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
69302>>>>>>>>>
69302>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
69303>>>>>>>>>
69303>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
69304>>>>>>>>>
69304>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
69305>>>>>>>>>
69305>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
69306>>>>>>>>>
69306>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
69307>>>>>>>>>
69307>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
69308>>>>>>>>>    
69308>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
69309>>>>>>>>>
69309>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
69310>>>>>>>>>
69310>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
69311>>>>>>>>>
69311>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
69312>>>>>>>>>    
69312>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
69313>>>>>>>>>    
69313>>>>>>>
69313>>>>>>>Class cCryptographer is a cObject
69314>>>>>>>    
69314>>>>>>>    Procedure Construct_Object
69316>>>>>>>        Forward Send Construct_Object
69318>>>>>>>        
69318>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
69319>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
69320>>>>>>>        Property Integer    piCipher    CALG_RC4
69321>>>>>>>        Property Integer    piHash      CALG_MD5
69322>>>>>>>        
69322>>>>>>>        // Private properties
69322>>>>>>>        Property Handle     Private_phProv
69323>>>>>>>    End_Procedure
69324>>>>>>>    
69324>>>>>>>    
69324>>>>>>>    // Acquire key container handle
69324>>>>>>>    Function AcquireContext Returns Handle
69326>>>>>>>        Integer iProvider
69326>>>>>>>        String sProvider
69326>>>>>>>        Handle hProv
69326>>>>>>>        Boolean bOk
69326>>>>>>>        Address addrProv
69326>>>>>>>        
69326>>>>>>>        Move 0 to hProv
69327>>>>>>>        Get piProvider to iProvider
69328>>>>>>>        Get psProvider to sProvider
69329>>>>>>>        
69329>>>>>>>        //  Determine address to be passed as provider
69329>>>>>>>        If (Trim(sProvider) <> "") Begin
69331>>>>>>>            Move (AddressOf(sProvider)) to addrProv
69332>>>>>>>        End
69332>>>>>>>>
69332>>>>>>>        Else Begin
69333>>>>>>>            Move 0 to addrProv
69334>>>>>>>        End
69334>>>>>>>>
69334>>>>>>>        
69334>>>>>>>        //  Acquire Crypto Context
69334>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
69335>>>>>>>        If (not(bOk) or hProv = 0) Begin
69337>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
69338>>>>>>>        End
69338>>>>>>>>
69338>>>>>>>        
69338>>>>>>>        If (not(bOk) or hProv = 0) Begin
69340>>>>>>>            // Fallback to original
69340>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
69341>>>>>>>            
69341>>>>>>>            If (not(bOk) or hProv = 0) Begin
69343>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
69344>>>>>>>            End
69344>>>>>>>>
69344>>>>>>>        End
69344>>>>>>>>
69344>>>>>>>        Set Private_phProv to hProv
69345>>>>>>>        
69345>>>>>>>        Function_Return hProv
69346>>>>>>>    End_Function
69347>>>>>>>    
69347>>>>>>>    // Releases key container handle
69347>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
69349>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
69350>>>>>>>    End_Function
69351>>>>>>>    
69351>>>>>>>    // Creates hash object
69351>>>>>>>    Function CreateHash Handle hProv Returns Handle
69353>>>>>>>        Integer iAlgorithm
69353>>>>>>>        Handle hHash
69353>>>>>>>        Boolean bOk
69353>>>>>>>        
69353>>>>>>>        Move 0 to hHash
69354>>>>>>>        Get piHash to iAlgorithm
69355>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
69356>>>>>>>        
69356>>>>>>>        Function_Return hHash
69357>>>>>>>    End_Function
69358>>>>>>>    
69358>>>>>>>    // Destroys the hash object
69358>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
69360>>>>>>>        Function_Return (CryptDestroyHash(hHash))
69361>>>>>>>    End_Function
69362>>>>>>>    
69362>>>>>>>    // Adds data to hash object
69362>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
69364>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
69365>>>>>>>    End_Function
69366>>>>>>>    
69366>>>>>>>    // Generates session key
69366>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
69368>>>>>>>        Integer iAlgorithm
69368>>>>>>>        Handle hKey
69368>>>>>>>        Boolean bOk
69368>>>>>>>        
69368>>>>>>>        Move 0 to hKey
69369>>>>>>>        Get piCipher to iAlgorithm
69370>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
69371>>>>>>>        
69371>>>>>>>        Function_Return hKey
69372>>>>>>>    End_Function
69373>>>>>>>    
69373>>>>>>>    // Imports a plain text key
69373>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
69375>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69375>>>>>>>        tPLAINTEXTKEYBLOB blobhead
69375>>>>>>>        Boolean   bSuccess
69375>>>>>>>        Handle    hKey
69375>>>>>>>        Integer   iHeadSize iKeySize
69375>>>>>>>        UChar[]   ucaKeyblob
69376>>>>>>>        Integer iVoid
69376>>>>>>>        
69376>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
69377>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
69378>>>>>>>        
69378>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
69379>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
69380>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
69381>>>>>>>        Move iKeySize           to blobhead.dwKeySize
69382>>>>>>>        
69382>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
69383>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
69384>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
69385>>>>>>>        
69385>>>>>>>        Move 0 to hKey
69386>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
69387>>>>>>>        If (not(bSuccess)) Begin
69389>>>>>>>            Move (ShowLastError()) to iVoid
69390>>>>>>>        End
69390>>>>>>>>
69390>>>>>>>        
69390>>>>>>>        Function_Return hKey
69391>>>>>>>    End_Function
69392>>>>>>>    
69392>>>>>>>    // Destroys the key
69392>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
69394>>>>>>>        Function_Return (CryptDestroyKey(hKey))
69395>>>>>>>    End_Function
69396>>>>>>>    
69396>>>>>>>    // Retrieves key data
69396>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
69398>>>>>>>        Integer iBuffer iLen
69398>>>>>>>        Boolean bOk
69398>>>>>>>        
69398>>>>>>>        Move (SizeOfType(Integer)) to iLen
69399>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
69400>>>>>>>        Function_Return iBuffer
69401>>>>>>>    End_Function
69402>>>>>>>    
69402>>>>>>>    // Retrieves a hash value
69402>>>>>>>    Function HashValue Handle lhHash Returns String
69404>>>>>>>        String  lsHash
69404>>>>>>>        Integer liResult
69404>>>>>>>        DWord   dwDataLen
69404>>>>>>>        
69404>>>>>>>        Move 0 to dwDataLen
69405>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
69406>>>>>>>        If (liResult = 0) ;            Function_Return ""
69409>>>>>>>        
69409>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
69410>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
69411>>>>>>>        If (liResult = 0) ;            Function_Return ""
69414>>>>>>>        
69414>>>>>>>        Function_Return lsHash
69415>>>>>>>    End_Function
69416>>>>>>>
69416>>>>>>>    // Encrypts data
69416>>>>>>>    Function Encrypt String sPassword String sData Returns String
69418>>>>>>>        Handle hProv hHash hKey
69418>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
69418>>>>>>>        Boolean bOk
69418>>>>>>>        
69418>>>>>>>        Get AcquireContext to hProv
69419>>>>>>>        If (hProv) Begin
69421>>>>>>>            Get CreateHash hProv to hHash
69422>>>>>>>            If (hHash) Begin
69424>>>>>>>                Get HashData hHash sPassword to bOk
69425>>>>>>>                If (bOk) Begin
69427>>>>>>>                    Get piCipher to iAlgorithm
69428>>>>>>>                    Get DeriveKey hProv hHash to hKey
69429>>>>>>>                End
69429>>>>>>>>
69429>>>>>>>                Get DestroyHash hHash to bOk
69430>>>>>>>            End
69430>>>>>>>>
69430>>>>>>>            
69430>>>>>>>            If (hKey) Begin
69432>>>>>>>                //  First call to determine resulting data size
69432>>>>>>>                Move (Length(sData)) to iDataLen
69433>>>>>>>                Move (Length(sData)) to iCipherLen
69434>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
69435>>>>>>>                
69435>>>>>>>                //  Reserve space in string
69435>>>>>>>                If (iDataLen < iCipherLen) Begin
69437>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
69438>>>>>>>                End
69438>>>>>>>>
69438>>>>>>>                
69438>>>>>>>                //  Call to really decrypt
69438>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
69439>>>>>>>                //If (not(bOk)) Begin
69439>>>>>>>                //Move "" to sData
69439>>>>>>>                //Move (GetLastError()) to iErr
69439>>>>>>>                //End
69439>>>>>>>                
69439>>>>>>>                Get DestroyKey hKey to bOk
69440>>>>>>>            End 
69440>>>>>>>>
69440>>>>>>>            Get ReleaseContext hProv to bOk
69441>>>>>>>        End 
69441>>>>>>>>
69441>>>>>>>        Function_Return sData
69442>>>>>>>    End_Function
69443>>>>>>>    
69443>>>>>>>    // Decrypts data
69443>>>>>>>    Function Decrypt String sPassword String sData Returns String
69445>>>>>>>        Handle hProv hHash hKey
69445>>>>>>>        Integer iAlgorithm iDataLen
69445>>>>>>>        Boolean bOk
69445>>>>>>>        
69445>>>>>>>        Get AcquireContext to hProv
69446>>>>>>>        If (hProv) Begin
69448>>>>>>>            Get CreateHash hProv to hHash
69449>>>>>>>            If (hHash) Begin
69451>>>>>>>                Get HashData hHash sPassword to bOk
69452>>>>>>>                If (bOk) Begin
69454>>>>>>>                    Get piCipher to iAlgorithm
69455>>>>>>>                    Get DeriveKey hProv hHash to hKey
69456>>>>>>>                End
69456>>>>>>>>
69456>>>>>>>                Get DestroyHash hHash to bOk
69457>>>>>>>            End
69457>>>>>>>>
69457>>>>>>>            
69457>>>>>>>            If (hKey) Begin
69459>>>>>>>                Move (Length(sData)) to iDataLen
69460>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
69461>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
69461>>>>>>>                If (Length(sData) > iDataLen) Begin
69463>>>>>>>                    Move (Left(sData, iDataLen)) to sData
69464>>>>>>>                End
69464>>>>>>>>
69464>>>>>>>                
69464>>>>>>>                Get DestroyKey hKey to bOk
69465>>>>>>>            End
69465>>>>>>>>
69465>>>>>>>            Get ReleaseContext hProv to bOk
69466>>>>>>>        End
69466>>>>>>>>
69466>>>>>>>        Function_Return sData
69467>>>>>>>    End_Function
69468>>>>>>>    
69468>>>>>>>    //  Generates random data.
69468>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
69470>>>>>>>        Handle hProv
69470>>>>>>>        UChar[] uaResult
69471>>>>>>>        Boolean bRes
69471>>>>>>>        
69471>>>>>>>        Get AcquireContext to hProv
69472>>>>>>>        
69472>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
69473>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
69474>>>>>>>        
69474>>>>>>>        Get ReleaseContext hProv to bRes
69475>>>>>>>        
69475>>>>>>>        Function_Return uaResult
69476>>>>>>>    End_Function
69477>>>>>>>    
69477>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
69477>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
69479>>>>>>>        String sResult
69479>>>>>>>        UChar[] aData
69480>>>>>>>        Address pBase64
69480>>>>>>>        Integer iVoid
69480>>>>>>>        
69480>>>>>>>        Get GenerateRandom iLenght to aData
69481>>>>>>>        
69481>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
69482>>>>>>>        Move pBase64 to sResult
69483>>>>>>>        Move (Free(pBase64)) to iVoid
69484>>>>>>>        
69484>>>>>>>        Function_Return (Left(sResult, iLenght))
69485>>>>>>>    End_Function
69486>>>>>>>    
69486>>>>>>>End_Class
69487>>>>>
69487>>>>>Class cLoginEncryption is a cObject
69488>>>>>    
69488>>>>>    Procedure Construct_Object
69490>>>>>        Forward Send Construct_Object
69492>>>>>        // this must be set to a multi (40ish) character random key
69492>>>>>        Property String psEncryptPassword ""
69493>>>>>        
69493>>>>>        Object oDataCrypter is a cCryptographer
69495>>>>>            Set piHash to CALG_SHA_256
69496>>>>>            Set piCipher to CALG_AES_256
69497>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
69498>>>>>            Set piProvider to PROV_RSA_AES
69499>>>>>        End_Object
69500>>>>>    End_Procedure
69501>>>>>    
69501>>>>>    // This can be augmented to return a password encryption key using any
69501>>>>>    // hidden mechanism desired.
69501>>>>>    Function GetEncryptionPassword Returns String
69503>>>>>        String sPassword
69503>>>>>        Get psEncryptPassword to sPassword
69504>>>>>        Function_Return sPassword
69505>>>>>    End_Function
69506>>>>>    
69506>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
69506>>>>>    //
69506>>>>>    // Params:
69506>>>>>    //   sPlainText     String to encrypt.
69506>>>>>    // Returns:
69506>>>>>    //   Base64 encoded hash.
69506>>>>>    Function EncryptPassword String sPlainText Returns String
69508>>>>>        String sEncryptPassword sBinary sBase64
69508>>>>>        Address pBase64
69508>>>>>        Integer iVoid
69508>>>>>        
69508>>>>>        //  Encrypt Key
69508>>>>>        Get GetEncryptionPassword to sEncryptPassword
69509>>>>>        If (sEncryptPassword = "") Begin
69511>>>>>            Error DFERR_PROGRAM "No encryption password set"
69512>>>>>>
69512>>>>>        End
69512>>>>>>
69512>>>>>        
69512>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
69513>>>>>        
69513>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
69515>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
69516>>>>>>
69516>>>>>            Function_Return ""
69517>>>>>        End
69517>>>>>>
69517>>>>>        
69517>>>>>        //  Encode binary hash to Base64
69517>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
69518>>>>>        Move pBase64 to sBase64
69519>>>>>        Move (Free(pBase64)) to iVoid
69520>>>>>        
69520>>>>>        Function_Return sBase64
69521>>>>>    End_Function
69522>>>>>    
69522>>>>>    
69522>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
69522>>>>>    //
69522>>>>>    // Params:
69522>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
69522>>>>>    // Returns:
69522>>>>>    //   Readable plain text password
69522>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
69524>>>>>        String sEncryptPassword sPlainText sBinary
69524>>>>>        Boolean bIsHex
69524>>>>>        Integer iLen iVoid
69524>>>>>        Address pBinary
69524>>>>>        
69524>>>>>        If (sBase64EncryptedPassword <> "") Begin
69526>>>>>            //  Decode from Base64
69526>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
69527>>>>>            
69527>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
69528>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
69529>>>>>            
69529>>>>>            Move (Free(pBinary)) to iVoid
69530>>>>>            
69530>>>>>            //  Encrypted binary hash to string
69530>>>>>            Get GetEncryptionPassword to sEncryptPassword
69531>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
69532>>>>>        End
69532>>>>>>
69532>>>>>        
69532>>>>>        Function_Return sPlainText
69533>>>>>    End_Function
69534>>>>>End_Class
69535>>>
69535>>>Object oLoginEncryption is a cLoginEncryption
69537>>>
69537>>>    // this must be created in your appsrc directory and must contain an encryption
69537>>>    // key that is set to psEncryptPassword. It will look something like this
69537>>>    //
69537>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
69537>>>    //  
Including file: LoginEncryptionKey.inc    (E:\GitHub\DataFlex-IO\DFD-Library\AppSrc\LoginEncryptionKey.inc)
69537>>>>// Studio generated login encryption key
69537>>>>Set psEncryptPassword to "<2uOgYqj%l6JqQ//K^wX:%2V#[A0jv[E^Y\8l(^Y"
69538>>>>
69538>>>    
69538>>>    // use this to register this object to your cConnection Object. This object
69538>>>    // must be created after the cConnection object
69538>>>    Move Self to ghoLoginEncryption
69539>>>End_Object
69540>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\DatabaseLoginDialog.dg)
69540>>>
69540>>>Use Windows.pkg
69540>>>Use cConnection.pkg
69540>>>Use dfLine.pkg
69540>>>
69540>>>Object oDatabaseLoginDialog is a ModalPanel
69542>>>    Set Label to "Database Login"
69543>>>    Set Location to 2 2
69544>>>    Set Size to 110 211
69545>>>    
69545>>>    Property String psId
69547>>>    Property Boolean pbOk False
69549>>>    Property Boolean pbChanged False
69551>>>    Property Boolean pbAllowRemember True
69553>>>    
69553>>>    // this registers this object with the cConnection object.
69553>>>    Move Self to ghoLoginConnectDialog
69554>>>    
69554>>>    Object oUserIDForm is a Form
69556>>>        Set Label to "User Name"
69557>>>        Set Size to 12 85
69558>>>        Set Location to 34 79
69559>>>        Set Label_Col_Offset to 64
69560>>>        Set peAnchors to anTopLeftRight
69561>>>    End_Object
69562>>>    
69562>>>    Object oPwdForm is a Form
69564>>>        Set Size to 12 85
69565>>>        Set Location to 49 79
69566>>>        Set Label_Col_Offset to 64
69567>>>        Set Password_State to True
69568>>>        Set peAnchors to anTopLeftRight
69569>>>        Set Label to "Password"
69570>>>    End_Object
69571>>>    
69571>>>    Object oTrustedConnection is a CheckBox
69573>>>        Set Size to 10 50
69574>>>        Set Location to 65 79
69575>>>        Set Label to "Trusted Connection"
69576>>>    End_Object
69577>>>    
69577>>>    Object oRemember is a CheckBox
69579>>>        Set Size to 10 50
69580>>>        Set Location to 79 14
69581>>>        Set Label to "Remember and don't ask again"
69582>>>        Set Checked_State to True
69583>>>    End_Object
69584>>>    
69584>>>    Object oLogin_btn is a Button
69586>>>        Set Label to "&Login"
69587>>>        Set Location to 92 102
69588>>>        Set peAnchors to anBottomRight
69589>>>        Set Default_State to True
69590>>>        
69590>>>        Procedure OnClick
69593>>>            Boolean bTrust
69593>>>            String sUser sPwd sConn sErr sId
69593>>>            Integer iError
69593>>>            Get psId to sId
69594>>>            Get Value of oUserIDForm to sUser
69595>>>            Get Value of oPwdForm to sPwd
69596>>>            Get Checked_State of oTrustedConnection to bTrust
69597>>>            
69597>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
69598>>>            If (iError=0) Begin
69600>>>                Set pbOk to True
69601>>>                Set pbChanged to True
69602>>>                Send Close_Panel
69603>>>            End
69603>>>>
69603>>>            Else Begin
69604>>>                Get psErrorText of ghoConnection to sErr
69605>>>                Send UserError sErr "Login Error"
69606>>>            End
69606>>>>
69606>>>        End_Procedure
69607>>>    End_Object
69608>>>    
69608>>>    Object oCancel_btn is a Button
69610>>>        Set Label to "&Cancel"
69611>>>        Set Location to 92 157
69612>>>        Set peAnchors to anBottomRight
69613>>>        
69613>>>        Procedure OnClick
69616>>>            Send Close_Panel
69617>>>        End_Procedure
69618>>>    End_Object
69619>>>    
69619>>>    Object oConnectionIdInfo is a TextBox
69621>>>        Set Size to 10 50
69622>>>        Set Location to 4 14
69623>>>        Set Label to 'Connection Id='
69624>>>    End_Object
69625>>>    
69625>>>    Object oConnectionServerInfo is a TextBox
69627>>>        Set Size to 10 50
69628>>>        Set Location to 16 14
69629>>>        Set Label to 'Server'
69630>>>    End_Object
69631>>>    
69631>>>    Object oLineControl1 is a LineControl
69633>>>        Set Size to 2 202
69634>>>        Set Location to 29 5
69635>>>    End_Object
69636>>>    
69636>>>    Function LoginConnectIdDialog String sId Returns Boolean
69639>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
69639>>>        String sUser sPwd sDescription
69639>>>        tConnection Connect
69639>>>        tConnection Connect
69639>>>        
69639>>>        Get pbAllowRemember to bAllowRemember
69640>>>        
69640>>>        
69640>>>        If not bAllowRemember Begin
69642>>>            Set Enabled_State of oRemember to bRemember
69643>>>            Set Visible_State of oRemember to bRemember
69644>>>        End
69644>>>>
69644>>>        
69644>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
69645>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
69646>>>        Set Value of oConnectionServerInfo to Connect.sString
69647>>>        
69647>>>        Set psId to sId
69648>>>        Set pbOk to False
69649>>>        Set pbChanged to False
69650>>>        Set Value of oUserIDForm to Connect.sUID
69651>>>        Set Value of oPwdForm to ""
69652>>>        
69652>>>        Send Popup
69653>>>        
69653>>>        Get pbOk to bOk
69654>>>        Get pbChanged to bChanged
69655>>>        If (bChanged and bOk) Begin
69657>>>            If bAllowRemember Begin
69659>>>                Get Checked_State of oRemember to bRemember
69660>>>                If bRemember Begin
69662>>>                    Get Checked_State of oTrustedConnection to bTrusted
69663>>>                    If not (bTrusted) Begin
69665>>>                        Get Value of oUserIDForm to sUser
69666>>>                        Get Value of oPwdForm to sPwd
69667>>>                    End
69667>>>>
69667>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
69668>>>                End
69668>>>>
69668>>>            End
69668>>>>
69668>>>        End
69668>>>>
69668>>>        Function_Return bOk
69669>>>    End_Function
69670>>>    
69670>>>    
69670>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
69671>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
69672>>>End_Object
69673>>>
69673>    End_Object
69674>
69674>End_Object
69675>
69675>Object oToolTipController is a cToolTipController
69677>    Move Self to ghoToolTipController
69678>End_Object
69679>
69679>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
69679>>>Use cCJStandardMenuItemClasses.pkg
69679>>>
69679>>>Object oEditContextMenu is a cCJContextMenu
69681>>>    
69681>>>    Move Self to Default_Form_Floating_Menu_ID
69682>>>    
69682>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69684>>>    End_Object
69685>>>    
69685>>>    Object oCutMenuItem is a cCJCutMenuItem
69687>>>        Set pbControlBeginGroup to True
69688>>>    End_Object
69689>>>    
69689>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69691>>>    End_Object
69692>>>
69692>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69694>>>    End_Object
69695>>>
69695>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69697>>>    End_Object
69698>>>
69698>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69700>>>        Set pbControlBeginGroup to True
69701>>>    End_Object
69702>>>
69702>>>End_Object
69703>>>
69703>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu17.pkg)
69703>>>Use Windows.pkg
69703>>>Use cCJStandardMenuItemClasses.pkg
69703>>>Use cCJDeoMenuItemClasses.pkg
69703>>>
69703>>>
69703>>>Object oDEOEditContextMenu17 is a cCJContextMenu
69705>>>    
69705>>>    Move Self to Default_dbFloating_Menu_ID
69706>>>    
69706>>>    Object oUndoMenuItem is a cCJUndoMenuItem
69708>>>    End_Object
69709>>>    
69709>>>    Object oCutMenuItem is a cCJCutMenuItem
69711>>>        Set pbControlBeginGroup to True
69712>>>    End_Object
69713>>>    
69713>>>    Object oCopyMenuItem is a cCJCopyMenuItem
69715>>>    End_Object
69716>>>
69716>>>    Object oPasteMenuItem is a cCJPasteMenuItem
69718>>>    End_Object
69719>>>
69719>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
69721>>>    End_Object
69722>>>
69722>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
69724>>>        Set pbControlBeginGroup to True
69725>>>    End_Object
69726>>>
69726>>>    Object oPromptMenuItem is a cCJPromptMenuItem
69728>>>        Set pbControlBeginGroup to True
69729>>>    End_Object
69730>>>
69730>>>    Object oFindNextMenu is a cCJFindNextMenuItem
69732>>>        Set pbControlBeginGroup to True
69733>>>    End_Object
69734>>>
69734>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69736>>>    End_Object
69737>>>
69737>>>    Object oClearMenuItem is a cCJClearMenuItem
69739>>>        Set pbControlBeginGroup to True
69740>>>    End_Object
69741>>>
69741>>>    Object oClearAllMenu is a cCJClearAllMenuItem
69743>>>    End_Object
69744>>>
69744>>>    Object oSaveMenu is a cCJSaveMenuItem
69746>>>    End_Object
69747>>>    
69747>>>    Object oDeleteMenu is a cCJDeleteMenuItem
69749>>>    End_Object
69750>>>
69750>>>    Object oRememberitem is a cCJRememberFieldMenuItem
69752>>>        Set pbControlBeginGroup to True
69753>>>    End_Object
69754>>>
69754>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
69756>>>    End_Object
69757>>>
69757>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
69759>>>    End_Object
69760>>>
69760>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
69762>>>    End_Object
69763>>>
69763>>>End_Object
69764>
69764>Object oMain is a Panel
69766>    Set Label To "My Project"
69767>    Set Location to 4 3
69768>    Set Size to 300 450
69769>
69769>    Object oCommandBarSystem is a cCJCommandBarSystem
69771>        Set pbTimerUpdate to True
69772>        Set peVisualTheme to xtpThemeOffice2013Outlook
69773>        Set pbAutoResizeIcons to True
69774>
69774>        Procedure OnCreateCommandBars
69777>            Handle hoOptions
69777>            Get OptionsObject to hoOptions
69778>            Forward Send OnCreateCommandBars
69780>        End_Procedure
69781>
69781>        Object oMenuBar is a cCJMenuBar
69783>
69783>            Object oFileMenu is a cCJMenuItem
69785>                Set peControlType to xtpControlPopup          
69786>                Set psCaption   to "&File"
69787>                Set psDescription to "Find, Save, Delete, Clear information or quit this application."
69788>                Set psCategory to "Menus"
69789>
69789>                Object oClearMenuItem is a cCJClearMenuItem
69791>                    Set pbAddToDesignerMenu to True
69792>                End_Object
69793>
69793>                Object oClearAllMenu is a cCJClearAllMenuItem
69795>                    Set pbAddToDesignerMenu to True
69796>                End_Object
69797>
69797>                Object oPromptMenuItem is a cCJPromptMenuItem
69799>                    Set pbAddToDesignerMenu to True
69800>                    Set pbControlBeginGroup to True
69801>                End_Object
69802>
69802>                Object oFindMenuItem is a cCJFindMenuItem
69804>                    Set pbAddToDesignerMenu to True
69805>                    Set pbControlBeginGroup to True
69806>                End_Object
69807>
69807>                Object oFindNextMenu is a cCJFindNextMenuItem
69809>                    Set pbAddToDesignerMenu to True
69810>                End_Object
69811>
69811>                Object oFindPreviousMenu is a cCJFindPreviousMenuItem
69813>                    Set pbAddToDesignerMenu to True
69814>                End_Object
69815>
69815>                Object oFindFirstMenu is a cCJFindFirstMenuItem
69817>                    Set pbAddToDesignerMenu to True
69818>                End_Object
69819>
69819>                Object oFindLastMenu is a cCJFindLastMenuItem
69821>                    Set pbAddToDesignerMenu to True
69822>                End_Object
69823>
69823>                Object oSaveMenuItem is a cCJSaveMenuItem
69825>                    Set pbAddToDesignerMenu to True
69826>                    Set pbControlBeginGroup to True
69827>                End_Object
69828>
69828>                Object oDeleteMenuItem is a cCJDeleteMenuItem
69830>                    Set pbAddToDesignerMenu to True
69831>                End_Object
69832>
69832>                Object oExitMenu is a cCJExitMenuItem
69834>                    Set pbControlBeginGroup to True
69835>                End_Object
69836>
69836>            End_Object
69837>
69837>            Object oViewMenu is a cCJMenuItem
69839>                Set peControlType to xtpControlPopup          
69840>                Set psCaption to "&View"
69841>                Set psToolTip to "View"
69842>                Set psDescription to "Available Views"
69843>            End_Object
69844>            
69844>            Object oReportMenu is a cCJMenuItem
69846>                Set peControlType to xtpControlPopup          
69847>                Set psCaption to "&Report"
69848>                Set psToolTip to "Report"
69849>                Set psDescription to "Available Reports"
69850>            End_Object
69851>
69851>            Object oNavigateMenu is a cCJMenuItem
69853>                Set peControlType to xtpControlPopup      
69854>                Set psCaption to "&Navigate"    
69855>                Set psTooltip to "Navigate"    
69856>                Set psDescription to "Move to different areas of the application"
69857>
69857>                Object oNextAreaMenu is a cCJNextAreaMenu
69859>                End_Object
69860>
69860>                Object oPriorAreaMenu is a cCJPriorAreaMenu
69862>                End_Object
69863>
69863>                Object oNextViewMenu is a cCJNextViewMenu
69865>                End_Object
69866>
69866>                Object oPriorViewMenu is a cCJPriorViewMenu
69868>                End_Object
69869>
69869>                Object oPromptMenu is a cCJPromptMenuItem
69871>                    Set pbControlBeginGroup to True
69872>                End_Object
69873>
69873>                Object oZoomMenu is a cCJZoomMenuItem
69875>                End_Object
69876>
69876>            End_Object
69877>
69877>            Object oWindowMenu is a cCJMDIWindowsMenuItem
69879>                Set peControlType to xtpControlPopup
69880>                Set psCaption to "&Window"
69881>                Set psToolTip to "Window"
69882>                Set psDescription to "Display Current Views and set other display options."    
69883>
69883>                // These are the static windows items. More will be created in onInitPopup 
69883>                Object oDisplayOptionsMenu is a cCJMenuItem
69885>                    Set peControlType to xtpControlPopup          
69886>                    Set psCaption to "&Display Options"
69887>                    Set psToolTip to "Display Options"
69888>                    Set psDescription to "Set display options"
69889>
69889>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
69891>                    End_Object
69892>
69892>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
69894>                    End_Object
69895>
69895>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
69897>                        Set pbControlBeginGroup to True
69898>                    End_Object
69899>
69899>                End_Object
69900>
69900>                Object oCascadeMenu is a cCJCascadeMenuItem
69902>                    Set pbControlBeginGroup to True
69903>                End_Object
69904>
69904>                Object oHorizTile is a cCJTileHorizontally
69906>                End_Object
69907>
69907>                Object oVertTile is a cCJTileVertically
69909>                End_Object
69910>
69910>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
69912>                    Set pbControlBeginGroup to True
69913>                End_Object
69914>
69914>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
69916>                End_Object
69917>
69917>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
69919>                    Set pbControlBeginGroup to True
69920>                End_Object
69921>
69921>            End_Object
69922>
69922>            Object oHelpMenu is a cCJMenuItem
69924>                Set peControlType to xtpControlPopup    
69925>                Set psCaption to "&Help"
69926>                Set psDescription to "Access Information for learning and using this DataFlex application."
69927>                Set psToolTip to "Help"
69928>
69928>                Object oHelpMenuItem is a cCJHelpMenuItem 
69930>                End_Object
69931>
69931>                Object oAboutMenuItem is a cCJAboutMenuItem
69933>                End_Object
69934>
69934>            End_Object
69935>
69935>        End_Object
69936>
69936>        Object oFindToolBar is a cCJToolbar
69938>            Set psTitle to "Finding Toolbar"
69939>
69939>            Object oFindFirstTool is a cCJFindFirstMenuItem
69941>            End_Object
69942>
69942>            Object oFindPreviousTool is a cCJFindPreviousMenuItem
69944>            End_Object
69945>
69945>            Object oFindMenuTool is a cCJFindMenuItem
69947>            End_Object
69948>
69948>            Object oFindNextTool is a cCJFindNextMenuItem
69950>            End_Object
69951>
69951>            Object oFindLastTool is a cCJFindLastMenuItem
69953>            End_Object
69954>
69954>            Object oPromptToolItem is a cCJPromptMenuItem
69956>                Set pbControlBeginGroup to True
69957>            End_Object
69958>
69958>        End_Object
69959>
69959>        Object oFileToolBar is a cCJToolbar
69961>            Set psTitle to "Data Entry Toolbar"
69962>
69962>            Object oClearToolItem is a cCJClearMenuItem
69964>                Set peControlStyle to xtpButtonIconAndCaption
69965>            End_Object
69966>
69966>            Object oClearAllToolItem2 is a cCJClearAllMenuItem
69968>                Set peControlStyle to xtpButtonIconAndCaption
69969>            End_Object
69970>
69970>            Object oSaveToolItem is a cCJSaveMenuItem
69972>                Set peControlStyle to xtpButtonIconAndCaption
69973>                Set pbControlBeginGroup to True
69974>            End_Object
69975>
69975>            Object oDeleteToolItem is a cCJDeleteMenuItem
69977>                Set peControlStyle to xtpButtonIconAndCaption
69978>            End_Object
69979>
69979>        End_Object
69980>
69980>        Object oEditToolBar is a cCJToolbar
69982>            Set psTitle to "Edit Toolbar"
69983>
69983>            Object oCutToolbarItem is a cCJCutMenuItem
69985>            End_Object
69986>
69986>            Object oCopyToolbarItem is a cCJCopyMenuItem
69988>            End_Object
69989>
69989>            Object oPasteToolbarItem is a cCJPasteMenuItem
69991>            End_Object
69992>
69992>            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
69994>                Set pbControlBeginGroup to True
69995>            End_Object
69996>
69996>        End_Object
69997>
69997>        Object oRememberToolbar is a cCJToolbar
69999>            Set psTitle to C_$Remember
70000>
70000>            Object oRememberItems is a cCJMenuItem
70002>
70002>                Set peControlType to xtpControlPopup
70003>                Set peControlStyle to xtpButtonCaption
70004>                Set psCaption to C_$Remember
70005>                
70005>                Object oMenuItem is a cCJRememberFieldMenuItem
70007>                    Set peControlStyle to xtpButtonIconAndCaption
70008>                End_Object
70009>                
70009>                Object oMenuItem is a cCJRememberLastFieldMenuItem
70011>                    Set peControlStyle to xtpButtonIconAndCaption
70012>                End_Object
70013>                
70013>                Object oMenuItem is a cCJUnRememberFieldMenuItem
70015>                    Set peControlStyle to xtpButtonIconAndCaption
70016>                End_Object
70017>                
70017>                Object oMenuItem is a cCJUnRememberFieldAllMenuItem
70019>                    Set peControlStyle to xtpButtonIconAndCaption
70020>                End_Object
70021>
70021>            End_Object
70022>            
70022>        End_Object
70023>        
70023>        Object oStatusBar is a cCJStatusBar
70025>
70025>            Object oStatusPane1 is a cCJStatusBarPane
70027>                Set piID to sbpIDIdlePane
70028>                Set pbStyleStretch to True
70029>            End_Object
70030>
70030>            Object oStatusPane2 is a cCJStatusBarPane
70032>                Set phoViewPane to Self
70033>                Set pbStyleStretch to True
70034>            End_Object
70035>
70035>        End_Object
70036>
70036>    End_Object
70037>
70037>    Object oClientArea is a ClientArea
70039>        Use StdAbout.pkg
Including file: StdAbout.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\StdAbout.pkg)
70039>>>// This provides a quick and simple way to create an about package for a program.
70039>>>// You need to create a message inside you client area called Activate_About.
70039>>>// Within this message you should send the message DoAbout passing needed
70039>>>// string information.
70039>>>//
70039>>>//       Procedure Activate_About
70039>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
70039>>>//       End_Procedure
70039>>>//    where: sTitle =     Name of application. If none provided, uses caption
70039>>>//                        bar title
70039>>>//           sVersion   = Version Line. If none provided, will be blank
70039>>>//           sCopyRight = Copyright Line. If none provided, will be blank
70039>>>//           sAuthor    = Author name, blank if none provided
70039>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
70039>>>//                        is used.
70039>>>// It is expected that you will place this in your own object package. For
70039>>>// example an order about package may look like this:
70039>>>//
70039>>>//   // OrderAbout.pkg
70039>>>//   Use StdAbout.pkg
70039>>>//   Procedure Activate_About
70039>>>//      String sTitle sCopyright sVersion sAuthor
70039>>>//      Move "My Order Entry System" to sTitle
70039>>>//      Move "Version 2.1" to sVersion
70039>>>//      Move "Copyright xxxx, Super Software Inc." to sCopyright
70039>>>//      Move "John Smith"  to sAuthor
70039>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
70039>>>//   end_procedure
70039>>>//   // end of file.
70039>>>
70039>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\Dfabout.pkg)
70039>>>>>Use LanguageText.pkg
70039>>>>>Use Windows.pkg
70039>>>>>Use DFbitmap.pkg
70039>>>>>Use GlobalFunctionsProcedures.pkg
70039>>>>>Use cTextEdit.pkg
70039>>>>>Use tWinStructs.pkg
70039>>>>>
70039>>>>>Use cli.pkg
70039>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (E:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
70039>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
70039>>>>>>>// Notice      : This package contains constants and commands, used to call
70039>>>>>>>//               specific functions in the DFBTRDRV.
70039>>>>>>>Use Ui
70039>>>>>>>//
70039>>>>>>>// Driver Indentification
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>// Driver attributes
70039>>>>>>>//
70039>>>>>>>// Call_Driver functions ID's
70039>>>>>>>//
70039>>>>>>>//
70039>>>>>>>// DFBTRFN_CONVERT_FILE options
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// DFBTRFN_SET_OWNER options
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to create all vars which may be needed
70039>>>>>>>// in other commands.
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to set the owner of a Btrieve file.
70039>>>>>>>// File must have been opened.
70039>>>>>>>// Filenumber needs to be passed.
70039>>>>>>>// To clear set the owner to "".
70039>>>>>>>// Examples:
70039>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
70039>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
70039>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
70039>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
70039>>>>>>>// To clear:
70039>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to parse DFBTR_SET_OWNVER
70039>>>>>>>// options.
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to parse for Callback
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to clear the owner of a Btrieve file.
70039>>>>>>>// File must have been opened.
70039>>>>>>>// Filenumber needs to be passed.
70039>>>>>>>// Examples:
70039>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to add a owner name to the internal list of ownernames
70039>>>>>>>// which will be tries when opening files.
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to remove all owners from the internal list of ownernames
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to set the owner name to be used when opening the DDF files.
70039>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
70039>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
70039>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to change the transaction type.
70039>>>>>>>// Valid types are:
70039>>>>>>>//     DFBTRTT_NONE
70039>>>>>>>//     DFBTRTT_EXCLUSIVE
70039>>>>>>>//     DFBTRTT_CONCURRENT
70039>>>>>>>//
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to get the current transaction type.
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to set explicit_locking
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to get explicit locking
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>//
70039>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
70039>>>>>>>//
70039>>>>>>>
70039>>>>>>>// Purpose: An instance of this class can be used as a broker object to
70039>>>>>>>//          call several Dfbtrdrv releated methods.
70039>>>>>>>
70039>>>>>>>Class cDFBtrDrvHandler is an Array
70040>>>>>>>    
70040>>>>>>>    Procedure Construct_Object Integer iImage
70042>>>>>>>        Forward Send Construct_object iImage
70044>>>>>>>        
70044>>>>>>>        Property String  psDriverID "DFBTRDRV"
70045>>>>>>>    End_Procedure
70046>>>>>>>    
70046>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
70046>>>>>>>    //
70046>>>>>>>    
70046>>>>>>>    Function CKRevision Returns String
70048>>>>>>>        String  sDriverID
70048>>>>>>>        String  sRevision
70048>>>>>>>        String  sVoid
70048>>>>>>>        Integer iRetval
70048>>>>>>>        
70048>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70048>>>>>>>        // This error would otherwise be raised when we have an older
70048>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70048>>>>>>>        Send Ignore_error to Error_object_Id 20491
70049>>>>>>>        Get psDriverID to sDriverID
70050>>>>>>>        Move (Repeat(" ", 255)) to sRevision
70051>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
70056>>>>>>>        Send Trap_Error to Error_object_Id 20491
70057>>>>>>>        If (Trim(sRevision) = "") Begin
70059>>>>>>>            // Unable to get the revision. return all zeroes.
70059>>>>>>>            Move "0.0.0.0" to sRevision
70060>>>>>>>        End
70060>>>>>>>>
70060>>>>>>>        Function_Return sRevision
70061>>>>>>>    End_Function
70062>>>>>>>    
70062>>>>>>>    Function CkUsesUri Returns Integer
70064>>>>>>>        String  sDriverID
70064>>>>>>>        String  sVoid1
70064>>>>>>>        String  sVoid2
70064>>>>>>>        Integer iRetval
70064>>>>>>>        
70064>>>>>>>        Get psDriverID to sDriverID
70065>>>>>>>        
70065>>>>>>>        Move 0 to iRetval
70066>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70066>>>>>>>        // This error would otherwise be raised when we have an older
70066>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
70066>>>>>>>        Send Ignore_error to Error_object_Id 20491
70067>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
70072>>>>>>>        Send Trap_Error to Error_object_Id 20491
70073>>>>>>>        
70073>>>>>>>        Function_Return iRetval
70074>>>>>>>    End_Function
70075>>>>>>>    
70075>>>>>>>    
70075>>>>>>>    
70075>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
70075>>>>>>>    //
70075>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
70075>>>>>>>    //
70075>>>>>>>    
70075>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
70077>>>>>>>        Integer iPartRev
70077>>>>>>>        Integer iCurrentPart
70077>>>>>>>        Integer iSeparatorPos
70077>>>>>>>        
70077>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
70080>>>>>>>        
70080>>>>>>>        Move 0 to iCurrentPart
70081>>>>>>>        Repeat
70081>>>>>>>>
70081>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
70082>>>>>>>            If (iSeparatorPos > 0) Begin
70084>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
70085>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
70086>>>>>>>                Increment iCurrentPart
70087>>>>>>>            End
70087>>>>>>>>
70087>>>>>>>            Else If (sRevision <> "") Begin
70090>>>>>>>                Move sRevision to iPartRev
70091>>>>>>>                Move "" to sRevision
70092>>>>>>>                Increment iCurrentPart
70093>>>>>>>            End
70093>>>>>>>>
70093>>>>>>>            Else ;                Move -1 to iPartRev
70095>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
70097>>>>>>>        
70097>>>>>>>        Function_Return iPartRev
70098>>>>>>>    End_Function
70099>>>>>>>    
70099>>>>>>>    
70099>>>>>>>    
70099>>>>>>>    //
70099>>>>>>>    //  Returns the major revision of the CK
70099>>>>>>>    //
70099>>>>>>>    
70099>>>>>>>    Function CKMajorRevision Returns Integer
70101>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
70102>>>>>>>    End_Function
70103>>>>>>>    
70103>>>>>>>    
70103>>>>>>>    
70103>>>>>>>    //  Returns the minor revision of the CK
70103>>>>>>>    //
70103>>>>>>>    
70103>>>>>>>    Function CKMinorRevision Returns Integer
70105>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
70106>>>>>>>    End_Function
70107>>>>>>>    
70107>>>>>>>    
70107>>>>>>>    //  Returns the release revision of the CK
70107>>>>>>>    //
70107>>>>>>>    
70107>>>>>>>    Function CKReleaseRevision Returns Integer
70109>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
70110>>>>>>>    End_Function
70111>>>>>>>    
70111>>>>>>>    
70111>>>>>>>    //  Returns the major revision of the CK
70111>>>>>>>    //
70111>>>>>>>    
70111>>>>>>>    Function CKBuildRevision Returns Integer
70113>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
70114>>>>>>>    End_Function
70115>>>>>>>    
70115>>>>>>>    
70115>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
70115>>>>>>>    //
70115>>>>>>>    
70115>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
70117>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
70120>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
70123>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
70126>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
70129>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
70132>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
70136>>>>>>>            End
70136>>>>>>>>
70136>>>>>>>        End
70136>>>>>>>>
70136>>>>>>>        
70136>>>>>>>        Function_Return (False)
70137>>>>>>>    End_Function
70138>>>>>>>    
70138>>>>>>>    //   Functions to query the Pervasive.SQL version:
70138>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
70138>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
70138>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
70138>>>>>>>    //
70138>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
70138>>>>>>>    //   in the following format:
70138>>>>>>>    //       <version>.<revision>.<type>
70138>>>>>>>    //   possible values for <type>:
70138>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
70138>>>>>>>    //         server using Workgroup authentication mode
70138>>>>>>>    //       C for client cache engine
70138>>>>>>>    //       D for DOS workstation
70138>>>>>>>    //       N for client Requester
70138>>>>>>>    //       S for NetWare server
70138>>>>>>>    //       T for 32-bit Windows server engine
70138>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
70138>>>>>>>    //
70138>>>>>>>    //   example:
70138>>>>>>>    //       8.50.T
70138>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
70138>>>>>>>    //   32-bits Windows server.
70138>>>>>>>    //
70138>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
70138>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
70138>>>>>>>    //
70138>>>>>>>    //   If the version information is not available or can not be obtained
70138>>>>>>>    //   the functions will return "0.0.0"
70138>>>>>>>    
70138>>>>>>>    //  Returns the version information of the
70138>>>>>>>    //           Pervasive.SQL Client requester.
70138>>>>>>>    
70138>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
70140>>>>>>>        
70140>>>>>>>        String  sDriverID
70140>>>>>>>        String  sVersion
70140>>>>>>>        String  sVoid
70140>>>>>>>        Integer iRetval
70140>>>>>>>        
70140>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70140>>>>>>>        // This error would otherwise be raised when we have an older
70140>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70140>>>>>>>        Send Ignore_error to Error_object_Id 20491
70141>>>>>>>        Get psDriverID to sDriverID
70142>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70143>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70148>>>>>>>        Send Trap_Error to Error_object_Id 20491
70149>>>>>>>        If (Trim(sVersion) = "") Begin
70151>>>>>>>            // Unable to get the revision. return all zeroes.
70151>>>>>>>            Move "0.0.0" to sVersion
70152>>>>>>>        End
70152>>>>>>>>
70152>>>>>>>        Function_Return sVersion
70153>>>>>>>    End_Function
70154>>>>>>>    
70154>>>>>>>    //           Pervasive.SQL Engine
70154>>>>>>>    
70154>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
70156>>>>>>>        
70156>>>>>>>        String  sDriverID
70156>>>>>>>        String  sVersion
70156>>>>>>>        String  sVoid
70156>>>>>>>        Integer iRetval
70156>>>>>>>        
70156>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70156>>>>>>>        // This error would otherwise be raised when we have an older
70156>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70156>>>>>>>        Send Ignore_error to Error_object_Id 20491
70157>>>>>>>        Get psDriverID to sDriverID
70158>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70159>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70164>>>>>>>        Send Trap_Error to Error_object_Id 20491
70165>>>>>>>        If (Trim(sVersion) = "") Begin
70167>>>>>>>            // Unable to get the revision. return all zeroes.
70167>>>>>>>            Move "0.0.0" to sVersion
70168>>>>>>>        End
70168>>>>>>>>
70168>>>>>>>        Function_Return sVersion
70169>>>>>>>    End_Function
70170>>>>>>>    
70170>>>>>>>    //  Returns the version information of the
70170>>>>>>>    //           Pervasive.SQL Server Engine
70170>>>>>>>    
70170>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
70172>>>>>>>        
70172>>>>>>>        String  sDriverID
70172>>>>>>>        String  sVersion
70172>>>>>>>        String  sVoid
70172>>>>>>>        Integer iRetval
70172>>>>>>>        
70172>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70172>>>>>>>        // This error would otherwise be raised when we have an older
70172>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70172>>>>>>>        Send Ignore_error to Error_object_Id 20491
70173>>>>>>>        Get psDriverID to sDriverID
70174>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70175>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70180>>>>>>>        Send Trap_Error to Error_object_Id 20491
70181>>>>>>>        If (Trim(sVersion) = "") Begin
70183>>>>>>>            // Unable to get the revision. return all zeroes.
70183>>>>>>>            Move "0.0.0" to sVersion
70184>>>>>>>        End
70184>>>>>>>>
70184>>>>>>>        Function_Return sVersion
70185>>>>>>>    End_Function
70186>>>>>>>    
70186>>>>>>>End_Class
70187>>>>>>>
70187>>>>>>>
70187>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (E:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
70187>>>>>>>//     Package that declares MS SQL driver constants and functions.
70187>>>>>>>//     This package can be used by developers who want to add Data Access
70187>>>>>>>//     MS SQL Client specific code to a DataFlex application.
70187>>>>>>>
70187>>>>>>>Use Cli.pkg
70187>>>>>>>Use SQL.pkg
70187>>>>>>>
70187>>>>>>>//   Driver Indentification
70187>>>>>>>
70187>>>>>>>//   Error number constants
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>// SQL Server spcific types.
70187>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
70187>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
70187>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
70187>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
70187>>>>>>>
70187>>>>>>>// SQL Server spcific types.
70187>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
70187>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
70187>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
70187>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
70187>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
70187>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
70187>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
70187>>>>>>>//
70187>>>>>>>//     Setup a constraint for a file.
70187>>>>>>>
70187>>>>>>>
70187>>>>>>>Class cMSSQLHandler is a cCLIHandler
70188>>>>>>>    
70188>>>>>>>    Procedure Construct_Object
70190>>>>>>>        Forward Send Construct_Object
70192>>>>>>>        
70192>>>>>>>        Set psDriverID to MSSQLDRV_ID
70193>>>>>>>    End_Procedure
70194>>>>>>>    
70194>>>>>>>    
70194>>>>>>>    
70194>>>>>>>    //   Extract the list from the out connect string.
70194>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
70196>>>>>>>        String  sItem
70196>>>>>>>        Integer iStart
70196>>>>>>>        Integer iEnd
70196>>>>>>>        
70196>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
70199>>>>>>>        
70199>>>>>>>        Send Delete_Data to hoStore
70200>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
70201>>>>>>>        While (iStart > 0)
70205>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
70206>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
70209>>>>>>>            Else Begin
70210>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
70211>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
70212>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
70215>>>>>>>                
70215>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
70218>>>>>>>                
70218>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
70221>>>>>>>            End
70221>>>>>>>>
70221>>>>>>>        Loop
70222>>>>>>>>
70222>>>>>>>        
70222>>>>>>>        Function_Return (Item_Count(hoStore))
70223>>>>>>>    End_Function
70224>>>>>>>    
70224>>>>>>>    
70224>>>>>>>    
70224>>>>>>>    //   Call the driver's browse connect function
70224>>>>>>>    Function BrowseConnect String sInConnStr Returns String
70226>>>>>>>        String  sDriver
70226>>>>>>>        String  sOutConnStr
70226>>>>>>>        Integer iArg
70226>>>>>>>        Integer iRetval
70226>>>>>>>        
70226>>>>>>>        Get psDriverID to sDriver
70227>>>>>>>        If (sDriver <> "") Begin
70229>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
70230>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70235>>>>>>>        End
70235>>>>>>>>
70235>>>>>>>        
70235>>>>>>>        Function_Return sOutConnStr
70236>>>>>>>    End_Function// BrowseConnect
70237>>>>>>>    
70237>>>>>>>    
70237>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
70239>>>>>>>        String  sDriver
70239>>>>>>>        String  sOutConnStr
70239>>>>>>>        Integer iArg
70239>>>>>>>        Integer iRetval
70239>>>>>>>        
70239>>>>>>>        Move 1 to iArg // Browses only local
70240>>>>>>>        
70240>>>>>>>        Get psDriverID to sDriver
70241>>>>>>>        If (sDriver <> "") Begin
70243>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
70244>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70249>>>>>>>        End
70249>>>>>>>>
70249>>>>>>>        
70249>>>>>>>        Function_Return sOutConnStr
70250>>>>>>>    End_Function// BrowseConnect
70251>>>>>>>    
70251>>>>>>>    
70251>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
70253>>>>>>>        
70253>>>>>>>        String  sServerList
70253>>>>>>>        Integer iNumServers
70253>>>>>>>        Integer iDriver
70253>>>>>>>        Integer iClientVersion
70253>>>>>>>        String  sDriver
70253>>>>>>>        
70253>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
70254>>>>>>>        
70254>>>>>>>        If (iDriver) Begin
70256>>>>>>>            
70256>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
70259>>>>>>>            
70259>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
70260>>>>>>>            
70260>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
70261>>>>>>>            If (iNetworkLocal = 0) Begin
70263>>>>>>>                Get BrowseConnect sDriver to sServerList
70264>>>>>>>            End
70264>>>>>>>>
70264>>>>>>>            Else Begin
70265>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
70266>>>>>>>            End
70266>>>>>>>>
70266>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
70267>>>>>>>        End
70267>>>>>>>>
70267>>>>>>>        
70267>>>>>>>        Function_Return iNumServers
70268>>>>>>>        
70268>>>>>>>    End_Function
70269>>>>>>>    
70269>>>>>>>    //   Enumerate the available SQL Server database servers
70269>>>>>>>    //   This function will return all SQL Server instances on the network.
70269>>>>>>>    //   This may take a long time.
70269>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
70269>>>>>>>    Function EnumerateServers Returns Integer
70271>>>>>>>        
70271>>>>>>>        Integer iNumServers
70271>>>>>>>        Integer iNetworkLocal
70271>>>>>>>        
70271>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
70272>>>>>>>        
70272>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70273>>>>>>>        
70273>>>>>>>        Function_Return iNumServers
70274>>>>>>>        
70274>>>>>>>    End_Function
70275>>>>>>>    
70275>>>>>>>    
70275>>>>>>>    //   Enumerate the available SQL Server database servers
70275>>>>>>>    //   This function will return only return SQL Server instance on the local machine
70275>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
70275>>>>>>>    Function EnumerateServersLocal Returns Integer
70277>>>>>>>        
70277>>>>>>>        Integer iNumServers
70277>>>>>>>        Integer iNetworkLocal
70277>>>>>>>        
70277>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
70278>>>>>>>        
70278>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70279>>>>>>>        
70279>>>>>>>        Function_Return iNumServers
70280>>>>>>>        
70280>>>>>>>    End_Function
70281>>>>>>>    
70281>>>>>>>    
70281>>>>>>>    
70281>>>>>>>    //   Enumerate database in a given server.
70281>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
70283>>>>>>>        Integer hoSQL
70283>>>>>>>        String  sConnect
70283>>>>>>>        String  sDatabase
70283>>>>>>>        Integer hdbc
70283>>>>>>>        Integer hstmt
70283>>>>>>>        Integer iFetchResult
70283>>>>>>>        
70283>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
70286>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
70289>>>>>>>        
70289>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
70292>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
70294>>>>>>>        
70294>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
70296>>>>>>>            Move Current_Object to hoSQL
70297>>>>>>>        End_Object
70298>>>>>>>        
70298>>>>>>>        If (hoSQL <> 0) Begin
70300>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
70301>>>>>>>            If (hdbc <> 0) Begin
70303>>>>>>>                Get SQLOpen of hdbc to hstmt
70304>>>>>>>                If (hstmt <> 0) Begin
70306>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
70306>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
70306>>>>>>>                    //   approach in case meta data might change, the stored procedure will
70306>>>>>>>                    //   stay the same.
70306>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
70307>>>>>>>                    Send SQLCall to hstmt
70308>>>>>>>                    Repeat
70308>>>>>>>>
70308>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
70309>>>>>>>                        If (iFetchResult <> 0) Begin
70311>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
70312>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
70313>>>>>>>                        End
70313>>>>>>>>
70313>>>>>>>                    Until (iFetchResult = 0)
70315>>>>>>>                    
70315>>>>>>>                    Send SQLClose to hstmt
70316>>>>>>>                End
70316>>>>>>>>
70316>>>>>>>                Send SQLDisconnect to hdbc
70317>>>>>>>            End
70317>>>>>>>>
70317>>>>>>>        End
70317>>>>>>>>
70317>>>>>>>        Send Destroy_Object to hoSQL
70318>>>>>>>        
70318>>>>>>>        Function_Return (Item_Count(Current_Object))
70319>>>>>>>    End_Function
70320>>>>>>>    
70320>>>>>>>    
70320>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
70322>>>>>>>        
70322>>>>>>>        String  sSqlServerClientVersionName
70322>>>>>>>        
70322>>>>>>>        
70322>>>>>>>        Case Begin
70322>>>>>>>            
70322>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70324>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
70325>>>>>>>                Case Break
70326>>>>>>>                
70326>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70329>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
70330>>>>>>>                Case Break
70331>>>>>>>            
70331>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70334>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
70335>>>>>>>                Case Break
70336>>>>>>>            
70336>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70339>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
70340>>>>>>>                Case Break
70341>>>>>>>            
70341>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70344>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
70345>>>>>>>                Case Break
70346>>>>>>>            
70346>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70349>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
70350>>>>>>>                Case Break
70351>>>>>>>            
70351>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70354>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
70355>>>>>>>                Case Break
70356>>>>>>>            
70356>>>>>>>            Case Else
70356>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
70357>>>>>>>                
70357>>>>>>>        Case End
70357>>>>>>>        
70357>>>>>>>        
70357>>>>>>>        Function_Return sSqlServerClientVersionName
70358>>>>>>>        
70358>>>>>>>    End_Function
70359>>>>>>>
70359>>>>>>>
70359>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
70361>>>>>>>        
70361>>>>>>>        String  sSqlServerClientDriverName
70361>>>>>>>        
70361>>>>>>>        Case Begin
70361>>>>>>>            
70361>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70363>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
70364>>>>>>>                Case Break
70365>>>>>>>                
70365>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70368>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
70369>>>>>>>                Case Break
70370>>>>>>>            
70370>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70373>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
70374>>>>>>>                Case Break
70375>>>>>>>            
70375>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70378>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
70379>>>>>>>                Case Break
70380>>>>>>>            
70380>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70383>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
70384>>>>>>>                Case Break
70385>>>>>>>            
70385>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70388>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
70389>>>>>>>                Case Break
70390>>>>>>>            
70390>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70393>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70394>>>>>>>                Case Break
70395>>>>>>>            
70395>>>>>>>            Case Else
70395>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70396>>>>>>>                
70396>>>>>>>        Case End
70396>>>>>>>        
70396>>>>>>>        
70396>>>>>>>        Function_Return sSqlServerClientDriverName
70397>>>>>>>        
70397>>>>>>>    End_Function
70398>>>>>>>    
70398>>>>>>>    
70398>>>>>>>End_Class
70399>>>>>>>
70399>>>>>>>
70399>>>>>
70399>>>>>
70399>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
70400>>>>>
70400>>>>>Register_Function phoWorkspace Returns Handle
70400>>>>>Register_Function Help_filename Returns String
70400>>>>>Register_Function GetHelpFile Returns String
70400>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
70400>>>>>
70400>>>>>//    This function reads the current username Of windows and returns that
70400>>>>>//    name or an text unknown user
70400>>>>>Function Network_User_Name for cDesktop Returns String
70402>>>>>    String sName
70402>>>>>    Integer iRetval iLength
70402>>>>>    
70402>>>>>    Move 0 to iLength
70403>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
70404>>>>>    Move (ZeroString(iLength)) to sName
70405>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
70406>>>>>    
70406>>>>>    If (iRetval = NO_ERROR) Begin
70408>>>>>        Function_Return (CString (sName))
70409>>>>>    End
70409>>>>>>
70409>>>>>    
70409>>>>>    Function_Return "User Unknown"
70410>>>>>End_Function
70411>>>>>
70411>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
70412>>>>>
70412>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
70413>>>>>
70413>>>>>Class SysinfoDisplay is a cTextEdit
70414>>>>>    Procedure Construct_Object
70416>>>>>        Forward Send Construct_Object
70418>>>>>        
70418>>>>>        Set Location to 6 6
70419>>>>>        Set Size to 110 255
70420>>>>>        Set Read_Only_State to True
70421>>>>>        Set pbWrap to False
70422>>>>>    End_Procedure
70423>>>>>    
70423>>>>>    //    This method will show the name Of the current directory in the system
70423>>>>>    //    information box
70423>>>>>    Procedure Show_Current_Directory
70425>>>>>        String sDir
70425>>>>>        
70425>>>>>        Get_Current_Directory to sDir
70426>>>>>        
70426>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
70427>>>>>    End_Procedure
70428>>>>>    
70428>>>>>    Procedure Show_Windows_Directory
70430>>>>>        String sWindir
70430>>>>>        
70430>>>>>        Get_Windows_Directory to sWindir
70431>>>>>        
70431>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
70432>>>>>    End_Procedure
70433>>>>>    
70433>>>>>    Procedure Show_Current_User
70435>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
70436>>>>>    End_Procedure
70437>>>>>    
70437>>>>>    Procedure Show_Number_Format
70439>>>>>        Integer iFormat
70439>>>>>        String sFormatText
70439>>>>>        
70439>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
70442>>>>>        Move (Character (iFormat)) to sFormatText
70443>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
70444>>>>>        
70444>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
70447>>>>>        Move (Character (iFormat)) to sFormatText
70448>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
70449>>>>>    End_Procedure
70450>>>>>    
70450>>>>>    Procedure Show_Filelist_Name
70452>>>>>        String sFilename
70452>>>>>        
70452>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
70455>>>>>        
70455>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
70456>>>>>        Send AppendTextLn ""
70457>>>>>    End_Procedure
70458>>>>>    
70458>>>>>    Procedure Show_Lock_Delay
70460>>>>>        Integer iLockdelay
70460>>>>>        
70460>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
70463>>>>>        
70463>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
70464>>>>>    End_Procedure
70465>>>>>    
70465>>>>>    Procedure Show_Lock_Timeout
70467>>>>>        Integer iLockTimeout
70467>>>>>        
70467>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
70470>>>>>        
70470>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
70471>>>>>    End_Procedure
70472>>>>>    
70472>>>>>    Procedure Show_Screen_Size
70474>>>>>        Integer iYscreensize iXscreensize
70474>>>>>        
70474>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) to iXscreensize
70475>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) to iYscreensize
70476>>>>>        
70476>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
70477>>>>>    End_Procedure
70478>>>>>    
70478>>>>>    Procedure Show_Page_Size
70480>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
70481>>>>>    End_Procedure
70482>>>>>    
70482>>>>>    Procedure Show_Date
70484>>>>>        Date dToday
70484>>>>>        
70484>>>>>        Move (CurrentDateTime()) to  dToday
70485>>>>>        
70485>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
70486>>>>>    End_Procedure
70487>>>>>    
70487>>>>>    Procedure Show_Date_Format
70489>>>>>        Integer iDateFormat
70489>>>>>        String sDateFormat
70489>>>>>        
70489>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
70492>>>>>        Case Begin
70492>>>>>            Case (iDateFormat = DF_DATE_USA)
70494>>>>>                Move C_$USA to sDateFormat
70495>>>>>                Case Break
70496>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
70499>>>>>                Move C_$European to sDateFormat
70500>>>>>                Case Break
70501>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
70504>>>>>                Move C_$Military to sDateFormat
70505>>>>>                Case Break
70506>>>>>            Case Else
70506>>>>>                Move C_$UnknownDateType to sDateFormat
70507>>>>>                Case Break
70508>>>>>        Case End
70508>>>>>        
70508>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
70509>>>>>    End_Procedure
70510>>>>>    
70510>>>>>    Procedure Show_Systemresources
70512>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70512>>>>>        tWinMemoryStatusEx MemoryStatusInfo
70512>>>>>        Integer iRetval
70512>>>>>        
70512>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
70513>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
70514>>>>>        If (iRetval = 0) Begin
70516>>>>>            Move (ShowLastError ()) to iRetval
70517>>>>>        End
70517>>>>>>
70517>>>>>        
70517>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
70518>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
70519>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Integer ( Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0)))
70520>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Integer ( Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0)))
70521>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Integer ( Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0)))
70522>>>>>    End_Procedure
70523>>>>>    
70523>>>>>    Procedure Show_Registration
70525>>>>>        String sRegName
70525>>>>>        Integer iSN iMaxUsers
70525>>>>>        
70525>>>>>        Registration sRegName iSN
70526>>>>>>
70526>>>>>        
70526>>>>>        Get_Licensed_Max_Users to iMaxUsers
70527>>>>>        
70527>>>>>        Send AppendTextLn ""
70528>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
70529>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
70530>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
70531>>>>>    End_Procedure
70532>>>>>    
70532>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
70532>>>>>    // To the workspace object passing the an object and message To send back
70532>>>>>    // To this object. It is expected that the workspace object will send this
70532>>>>>    // message for every line Of information it wants displayed (passing the
70532>>>>>    // information To be displayed
70532>>>>>    Register_Procedure EnumerateWorkspaceData Handle hObjId Handle hmMessId
70532>>>>>    
70532>>>>>    Procedure Show_ServicePack
70534>>>>>        String sKey sVersionDescription sVersion
70534>>>>>        Handle hoRegistry
70534>>>>>        Boolean bExists bOpened
70534>>>>>        
70534>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
70535>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
70536>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
70537>>>>>        
70537>>>>>        Move C_DFVersionRegistryRoot to sKey
70538>>>>>        Get KeyExists of hoRegistry sKey to bExists
70539>>>>>        If (bExists) Begin
70541>>>>>            Get OpenKey of hoRegistry sKey to bOpened
70542>>>>>            If (bOpened) Begin
70544>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
70545>>>>>                If (bExists) Begin
70547>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
70548>>>>>                End
70548>>>>>>
70548>>>>>                
70548>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
70549>>>>>                If (bExists) Begin
70551>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
70552>>>>>                End
70552>>>>>>
70552>>>>>                Send CloseKey of hoRegistry
70553>>>>>            End
70553>>>>>>
70553>>>>>        End
70553>>>>>>
70553>>>>>        Send Destroy of hoRegistry
70554>>>>>        
70554>>>>>        If (sVersionDescription <> "") Begin
70556>>>>>            Send AppendTextLn (sVersionDescription * "-" * sVersion)
70557>>>>>            Send AppendTextLn ""
70558>>>>>        End
70558>>>>>>
70558>>>>>    End_Procedure
70559>>>>>    
70559>>>>>    
70559>>>>>    Procedure Show_WorkspaceInformation
70561>>>>>        Integer hoWorkspace
70561>>>>>        
70561>>>>>        If (ghoApplication <> 0) Begin
70563>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
70564>>>>>            If (hoWorkspace <> 0) Begin
70566>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
70567>>>>>                Send AppendTextLn ""
70568>>>>>            End
70568>>>>>>
70568>>>>>        End
70568>>>>>>
70568>>>>>    End_Procedure
70569>>>>>    
70569>>>>>    // If connection ids are used, we will send the message EnumerateConnections
70569>>>>>    // to the connection manager object passing the an object and message to send
70569>>>>>    // back to this object. It is expected that the connection manager object will
70569>>>>>    // send this message for every line Of information it wants displayed (passing
70569>>>>>    // the information To be displayed
70569>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
70569>>>>>    
70569>>>>>    Procedure Show_ConnectionIdInformation
70571>>>>>        If (ghoConnection > 0) Begin
70573>>>>>            Send AppendTextLn ""
70574>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
70575>>>>>        End
70575>>>>>>
70575>>>>>    End_Procedure
70576>>>>>    
70576>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
70578>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
70579>>>>>    End_Function
70580>>>>>    
70580>>>>>    Procedure Show_Versions
70582>>>>>        Integer iVersion iRevision iBuild
70582>>>>>        
70582>>>>>        Version_Information iVersion iRevision iBuild
70584>>>>>        
70584>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
70585>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
70586>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
70587>>>>>    End_Procedure
70588>>>>>    
70588>>>>>    Function CKRevisionNumber String sDriverID Returns String
70590>>>>>        Handle hoCLIHandler
70590>>>>>        Handle hoDFBtrDrvHandler
70590>>>>>        String sCKRevision
70590>>>>>        
70590>>>>>        
70590>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
70592>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
70593>>>>>            Set psDriverID of hoCLIHandler to sDriverID
70594>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
70595>>>>>            Send Destroy of hoCLIHandler
70596>>>>>        End
70596>>>>>>
70596>>>>>        Else Begin
70597>>>>>            If (sDriverID = "DFBTRDRV") Begin
70599>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
70600>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
70601>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
70602>>>>>                Send Destroy of hoDFBtrDrvHandler
70603>>>>>            End
70603>>>>>>
70603>>>>>        End
70603>>>>>>
70603>>>>>        
70603>>>>>        Function_Return sCKRevision
70604>>>>>    End_Function
70605>>>>>    
70605>>>>>    
70605>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
70607>>>>>        
70607>>>>>        If (sDriverID = "DATAFLEX") Begin
70609>>>>>            Function_Return False
70610>>>>>        End
70610>>>>>>
70610>>>>>        
70610>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
70611>>>>>    End_Function
70612>>>>>    
70612>>>>>    
70612>>>>>    Procedure Show_Drivers
70614>>>>>        String sCurrentDriver sRevNumber
70614>>>>>        String sLoadedDrivers sClientDriver
70614>>>>>        Integer iNumberOfDrivers iCount iClientVersion iMSSQLIndex
70614>>>>>        Boolean bOK
70614>>>>>        Handle hoMsqlDrv
70614>>>>>        
70614>>>>>        Move "" to sLoadedDrivers
70615>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
70618>>>>>        For iCount from 1 to iNumberOfDrivers
70624>>>>>>
70624>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
70627>>>>>            If (sLoadedDrivers <> "") Begin
70629>>>>>                Move (Append (sLoadedDrivers, ", ")) to sLoadedDrivers
70630>>>>>            End
70630>>>>>>
70630>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
70631>>>>>            If (bOK) Begin
70633>>>>>                If (sCurrentDriver = "MSSQLDRV") Begin
70635>>>>>                    Move iCount to iMSSQLIndex
70636>>>>>                End
70636>>>>>>
70636>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
70637>>>>>                // if mssqldrv, show the client number
70637>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
70638>>>>>            End
70638>>>>>>
70638>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) to sLoadedDrivers
70639>>>>>        Loop
70640>>>>>>
70640>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
70641>>>>>        If (iMSSQLIndex>0) Begin
70643>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iMSSQLIndex to iClientVersion
70646>>>>>            Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
70647>>>>>            Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
70648>>>>>            Send Destroy of hoMsqlDrv
70649>>>>>            Send AppendTextLn (SFormat("MSSQLDRV Client Version: %1", sClientDriver))
70650>>>>>        End
70650>>>>>>
70650>>>>>    End_Procedure
70651>>>>>    
70651>>>>>    Procedure Show_HelpFile
70653>>>>>        String sHelpFile
70653>>>>>        Integer eHelpType
70653>>>>>        
70653>>>>>        If (ghoApplication <> 0) Begin
70655>>>>>            Get peHelpType of ghoApplication to eHelpType
70656>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
70658>>>>>                Get GetHelpFile of ghoHtmlHelp to sHelpFile
70659>>>>>            End
70659>>>>>>
70659>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
70662>>>>>                Get Help_filename of Help_object_id to sHelpFile
70663>>>>>            End
70663>>>>>>
70663>>>>>            Else Begin
70664>>>>>                Move C_$ThereIsNoHelpfileDefined to sHelpFile
70665>>>>>            End
70665>>>>>>
70665>>>>>            
70665>>>>>            Send AppendTextLn ""
70666>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
70667>>>>>        End
70667>>>>>>
70667>>>>>    End_Procedure
70668>>>>>    
70668>>>>>    Procedure Show_EnterAsTab
70670>>>>>        Boolean bEnterKeyAsTabKey
70670>>>>>        String sText
70670>>>>>        
70670>>>>>        If (ghoApplication <> 0) Begin
70672>>>>>            Get pbEnterKeyAsTabKey of ghoApplication to bEnterKeyAsTabKey
70673>>>>>            If (bEnterKeyAsTabKey) Begin
70675>>>>>                Move "True" to sText
70676>>>>>            End
70676>>>>>>
70676>>>>>            Else Begin
70677>>>>>                Move "False" to sText
70678>>>>>            End
70678>>>>>>
70678>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
70679>>>>>        End
70679>>>>>>
70679>>>>>    End_Procedure
70680>>>>>    
70680>>>>>    //    During activation we will remove the old information and add the newly
70680>>>>>    //    found systeminformation
70680>>>>>    Procedure Add_Focus Integer hoRoot
70682>>>>>        Forward Send Add_Focus hoRoot
70684>>>>>        
70684>>>>>        Send Delete_Data
70685>>>>>        
70685>>>>>        Set Changed_State to False
70686>>>>>        Set Read_Only_State to True
70687>>>>>        
70687>>>>>        Send Show_ServicePack
70688>>>>>        Send Show_Versions
70689>>>>>        Send Show_Drivers
70690>>>>>        If (ghoConnection <> 0) Begin
70692>>>>>            Send Show_ConnectionIdInformation
70693>>>>>        End
70693>>>>>>
70693>>>>>        Send Show_HelpFile
70694>>>>>        Send Show_Current_Directory
70695>>>>>        Send Show_Filelist_Name
70696>>>>>        If (ghoApplication <> 0) Begin
70698>>>>>            Send Show_WorkSpaceInformation // added To show WS info
70699>>>>>        End
70699>>>>>>
70699>>>>>        Send Show_Current_User
70700>>>>>        Send Show_Windows_Directory
70701>>>>>        Send Show_Screen_Size
70702>>>>>        Send Show_Page_Size
70703>>>>>        Send Show_EnterAsTab
70704>>>>>        Send Show_Number_Format
70705>>>>>        Send Show_Date_Format
70706>>>>>        Send Show_Lock_Delay
70707>>>>>        Send Show_Lock_Timeout
70708>>>>>        Send Show_Date
70709>>>>>        Send Show_Systemresources
70710>>>>>        Send Show_Registration
70711>>>>>        Send Beginning_of_Data
70712>>>>>        
70712>>>>>        Set Icon to 'default.ico'
70713>>>>>    End_Procedure
70714>>>>>End_Class
70715>>>>>
70715>>>>>Class SysInfoDialog is a ModalPanel
70716>>>>>    Procedure Construct_Object
70718>>>>>        Forward Send Construct_Object
70720>>>>>        
70720>>>>>        Set Label to C_$SystemInformation
70721>>>>>        Set Size to 140 267
70722>>>>>        Set piMinSize to 140 267
70723>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70724>>>>>        Set Border_Style to Border_Thick
70725>>>>>        
70725>>>>>        Object oSysinfoDisplay is a SysInfoDisplay
70727>>>>>            Set peAnchors to anAll
70728>>>>>        End_Object
70729>>>>>        
70729>>>>>        Object oCloseButton is a Button
70731>>>>>            Set Label to C_$Close
70732>>>>>            Set Location to 120 210
70733>>>>>            Set Message 0 to (Refproc (Close_Panel))
70734>>>>>            Set Default_State to True
70735>>>>>            Set peAnchors to anBottomRight
70736>>>>>        End_Object
70737>>>>>        
70737>>>>>        On_Key kCancel Send Close_Panel
70738>>>>>    End_Procedure
70739>>>>>End_Class
70740>>>>>
70740>>>>>Class AboutDialog is a ModalPanel
70741>>>>>    Procedure Construct_Object
70743>>>>>        String sVdfRootDir
70743>>>>>        
70743>>>>>        Forward Send Construct_Object
70745>>>>>        
70745>>>>>        Set Label to C_$About
70746>>>>>        Set Size to 89 212
70747>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
70748>>>>>        
70748>>>>>        Object oSysInfoDialog is a SysInfoDialog
70750>>>>>        End_Object
70751>>>>>        
70751>>>>>        Object oBox is a Container3d
70753>>>>>            Set Border_Style to Border_StaticEdge
70754>>>>>            Set Size to 63 202
70755>>>>>            Set Location to 4 5
70756>>>>>            
70756>>>>>            Object oAboutGraphic is a BitmapContainer
70758>>>>>                Set Border_Style to Border_None
70759>>>>>                Set Bitmap_Style to Bitmap_Center
70760>>>>>                Set Size to 48 48
70761>>>>>                Set Location to 7 2
70762>>>>>            End_Object
70763>>>>>            
70763>>>>>            Object oProductName is a TextBox
70765>>>>>                Set Label to C_$ProductName
70766>>>>>                Set Size to 10 45
70767>>>>>                Set Location to 8 53
70768>>>>>            End_Object
70769>>>>>            
70769>>>>>            Object oVersion is a TextBox
70771>>>>>                Set Label to C_$Version
70772>>>>>                Set Size to 10 25
70773>>>>>                Set Location to 21 53
70774>>>>>            End_Object
70775>>>>>            
70775>>>>>            Object oCopyright is a TextBox
70777>>>>>                Set Label to C_$Copyright
70778>>>>>                Set Size to 10 31
70779>>>>>                Set Location to 34 53
70780>>>>>            End_Object
70781>>>>>            
70781>>>>>            Object oAuthor is a TextBox
70783>>>>>                Set Label to C_$Author
70784>>>>>                Set Size to 10 22
70785>>>>>                Set Location to 46 53
70786>>>>>            End_Object
70787>>>>>        End_Object
70788>>>>>        
70788>>>>>        Object oOKButton is a Button
70790>>>>>            On_Item C_$OK Send Close_Panel
70791>>>>>            Set Size to 14 50
70792>>>>>            Set Location to 71 157
70793>>>>>        End_Object
70794>>>>>        
70794>>>>>        Object oSysInfoButton is a Button
70796>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
70797>>>>>            Set Size to 14 50
70798>>>>>            Set Location to 71 101
70799>>>>>        End_Object
70800>>>>>        
70800>>>>>        On_Key Kcancel Send KeyAction of oOKButton
70801>>>>>        
70801>>>>>        Set Logo to "DacAbout.bmp"  // square bitmaps Of 42x42 work best
70802>>>>>    End_Procedure
70803>>>>>    
70803>>>>>    Procedure Set ProductName String sProductName
70805>>>>>        Set Label of oProductName to sProductName
70806>>>>>    End_Procedure
70807>>>>>    
70807>>>>>    Procedure Set Version String sVersion
70809>>>>>        Set Label of oVersion to sVersion
70810>>>>>    End_Procedure
70811>>>>>    
70811>>>>>    Procedure Set Copyright String sCopyright
70813>>>>>        Set Label of oCopyright to sCopyright
70814>>>>>    End_Procedure
70815>>>>>    
70815>>>>>    Procedure Set Author String sAuthor
70817>>>>>        Set Label of oAuthor to sAuthor
70818>>>>>    End_Procedure
70819>>>>>    
70819>>>>>    Procedure Set Logo String sLogo
70821>>>>>        // square bitmaps Of 42x42 work best
70821>>>>>        Set Bitmap of oAboutGraphic to sLogo
70822>>>>>    End_Procedure
70823>>>>>    
70823>>>>>    Procedure Show_Sysinfo
70825>>>>>        Send Popup_Modal of oSysinfoDialog
70826>>>>>    End_Procedure
70827>>>>>    
70827>>>>>    Procedure End_Construct_Object
70829>>>>>        Handle hoVersionInfo
70829>>>>>        Boolean bIncluded
70829>>>>>        Integer iMajor iMinor iRelease iBuild
70829>>>>>        String sLabel
70829>>>>>        
70829>>>>>        Get Label of oVersion to sLabel
70830>>>>>        If (sLabel = C_$VERSION) Begin
70832>>>>>            // set it To the version info Of the program, if available
70832>>>>>            If (ghoApplication <> 0) Begin
70834>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
70835>>>>>                If (hoVersionInfo <> 0) Begin
70837>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
70838>>>>>                    If (bIncluded) Begin
70840>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
70841>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
70842>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
70843>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
70844>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
70845>>>>>                        Set Version to sLabel
70846>>>>>                    End
70846>>>>>>
70846>>>>>                End
70846>>>>>>
70846>>>>>            End
70846>>>>>>
70846>>>>>        End
70846>>>>>>
70846>>>>>        
70846>>>>>        Forward Send End_Construct_Object
70848>>>>>    End_Procedure
70849>>>>>End_Class
70850>>>
70850>>>//  This is the default message. It is expected that you will
70850>>>//  create your own message to override this
70850>>>Procedure Activate_About
70853>>>    Send DoAbout "" "" "" "" ""
70854>>>End_Procedure
70855>>>
70855>>>//  It is expected that you will send this message (most
70855>>>//  likely from Activate_About. This creates an about object, activates it
70855>>>//  and destroys it when done. It is not exepected that you will augment this.
70855>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap
70858>>>    Integer hoObj hoMain
70858>>>    
70858>>>    // create object
70858>>>    Object About is an AboutDialog
70860>>>        // if no title passed use the label of the main panel
70860>>>        // (if a main panel exists).
70860>>>        If (sTitle = "") Begin
70862>>>            Get Main_Window of desktop to hoMain
70863>>>            If hoMain ;                Get Label of hoMain to sTitle
70866>>>        End
70866>>>>
70866>>>        Set productname to sTitle
70867>>>        Set version     to sVersion
70868>>>        Set copyright   to sCopyRight
70869>>>        Set author      to sAuthor
70870>>>        If (sBitmap <> '') ;            Set logo to sBitMap // square bitmaps of 42x42 work best
70873>>>        Move Self to hoObj // object Id
70874>>>    End_Object
70875>>>    Send Popup   of hoObj    // popup the about object
70876>>>    Send Destroy of hoObj // when done, it will be destroyed
70877>>>End_Procedure
70878>>>
70878>
70878>        Procedure Activate_About
70881>            Send DoAbout "" "" "" "" ""
70882>        End_Procedure
70883>
70883>    End_Object
70884>
70884>End_Object
70885>
70885>Start_UI
70886>
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 41523
Total Resources: 0
Total Commands : 70885
Total Windows  : 0
Total Pages    : 0
Static Data    : 398613
Message area   : 501075
Total Blocks   : 25555
